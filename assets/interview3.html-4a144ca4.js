import{_ as e,p as n,q as i,a1 as a}from"./framework-5866ffd3.js";const r={},s=a(`<h2 id="_1-什么是-spring-ioc-容器" tabindex="-1"><a class="header-anchor" href="#_1-什么是-spring-ioc-容器" aria-hidden="true">#</a> 1. 什么是 Spring IOC 容器？</h2><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p><h2 id="_2-可以通过多少种方式完成依赖注入" tabindex="-1"><a class="header-anchor" href="#_2-可以通过多少种方式完成依赖注入" aria-hidden="true">#</a> 2.可以通过多少种方式完成依赖注入？</h2><p>依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><h2 id="_3-spring-提供了哪些配置方式" tabindex="-1"><a class="header-anchor" href="#_3-spring-提供了哪些配置方式" aria-hidden="true">#</a> 3. spring 提供了哪些配置方式？</h2><ul><li>基于 xml 配置</li><li>基于注解配置</li><li>基于 Java API 配置</li></ul><h2 id="_4-如何理解ioc和di" tabindex="-1"><a class="header-anchor" href="#_4-如何理解ioc和di" aria-hidden="true">#</a> 4. 如何理解IoC和DI？</h2><p>IOC就是控制反转，通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。</p><p><strong>DI：DI—Dependency</strong> Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。</p><h2 id="_5-将一个类声明为spring的-bean-的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_5-将一个类声明为spring的-bean-的注解有哪些" aria-hidden="true">#</a> 5. 将一个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。 8 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="_6-spring-支持几种-bean-scope" tabindex="-1"><a class="header-anchor" href="#_6-spring-支持几种-bean-scope" aria-hidden="true">#</a> 6. spring 支持几种 bean scope？</h2><p>Spring bean 支持 5 种 scope：</p><ul><li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li><li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li><li><strong>Request</strong></li><li><strong>Session</strong></li><li><strong>Global-session</strong></li></ul><p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用</p><h2 id="_7-spring-中的-bean-生命周期" tabindex="-1"><a class="header-anchor" href="#_7-spring-中的-bean-生命周期" aria-hidden="true">#</a> 7. Spring 中的 bean 生命周期?</h2><p>Bean的生命周期是由容器来管理的。主要在创建和销毁两个时期。</p><p><img src="https://qfedu-1254123199.cos.ap-nanjing.myqcloud.com/img/1583675090641_51.png" alt="img"></p><h2 id="_8-spring-怎么解决循环依赖问题" tabindex="-1"><a class="header-anchor" href="#_8-spring-怎么解决循环依赖问题" aria-hidden="true">#</a> 8. Spring 怎么解决循环依赖问题？</h2><p>spring对循环依赖的处理有三种情况： ①<strong>构造器的循环依赖：这种依赖spring是处理不了的</strong>，直接抛出BeanCurrentlylnCreationException异常。 ②<strong>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖</strong>。 ③非单例循环依赖：无法处理。</p><h2 id="_9-什么是-aop" tabindex="-1"><a class="header-anchor" href="#_9-什么是-aop" aria-hidden="true">#</a> 9. 什么是 AOP？</h2><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p><h2 id="_10-aop-有哪些实现方式" tabindex="-1"><a class="header-anchor" href="#_10-aop-有哪些实现方式" aria-hidden="true">#</a> 10. AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p><ul><li>静态代理</li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 <ul><li><code>JDK</code> 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口</li><li><code>CGLIB</code>动态代理： 如果目标类没有实现接口，那么 <code>Spring AOP</code> 会选择使用 <code>CGLIB</code> 来动态代理目标类</li></ul></li></ul><h2 id="_11-springmvc-工作原理了解吗" tabindex="-1"><a class="header-anchor" href="#_11-springmvc-工作原理了解吗" aria-hidden="true">#</a> 11. SpringMVC 工作原理了解吗?</h2><p><img src="https://qfedu-1254123199.cos.ap-nanjing.myqcloud.com/img/SpingMVC-Process.jpg" alt="img"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h2 id="_12-spring-boot-的核心注解是哪个" tabindex="-1"><a class="header-anchor" href="#_12-spring-boot-的核心注解是哪个" aria-hidden="true">#</a> 12. Spring Boot 的核心注解是哪个？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><p>题目：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>. 什么是 Spring IOC 容器？
<span class="token number">2</span>. 可以通过多少种方式完成依赖注入？
<span class="token number">3</span>. spring 提供了哪些配置方式？
<span class="token number">4</span>. 如何理解IoC和DI？

<span class="token number">5</span>. 将一个类声明为Spring的 bean 的注解有哪些?
<span class="token number">6</span>. spring 支持几种 bean scope？
<span class="token number">7</span>. Spring 中的 bean 生命周期?
<span class="token number">8</span>. Spring 怎么解决循环依赖问题？

<span class="token number">9</span>. 什么是 AOP？
<span class="token number">10</span>. AOP 有哪些实现方式？
<span class="token number">11</span>. SpringMVC 工作原理了解吗?
<span class="token number">12</span>. Spring Boot 的核心注解是哪个？
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,38),o=[s];function d(l,c){return n(),i("div",null,o)}const t=e(r,[["render",d],["__file","interview3.html.vue"]]);export{t as default};
