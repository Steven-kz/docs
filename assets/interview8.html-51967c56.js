import{_ as n,p as a,q as e,a1 as s}from"./framework-5866ffd3.js";const l={},i=s(`<h2 id="_1-创建线程的三种方式的对比" tabindex="-1"><a class="header-anchor" href="#_1-创建线程的三种方式的对比" aria-hidden="true">#</a> 1. 创建线程的三种方式的对比？</h2><p><strong>1）采用实现Runnable. Callable接口的方式创建多线程。</strong></p><p><strong>优势是</strong>：</p><p>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</p><p>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU. 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p><p><strong>劣势是：</strong></p><p>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p><p><strong>2）使用继承Thread类的方式创建多线程</strong></p><p><strong>优势是：</strong></p><p>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</p><p><strong>劣势是：</strong></p><p>线程类已经继承了Thread类，所以不能再继承其他父类。</p><p><strong>3）Runnable和Callable的区别</strong></p><ul><li>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。</li><li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li><li>Call方法可以抛出异常，run方法不可以。</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li></ul><h2 id="_2-线程的状态流转" tabindex="-1"><a class="header-anchor" href="#_2-线程的状态流转" aria-hidden="true">#</a> 2. 线程的状态流转</h2><p>线程的生命周期及五种基本状态：</p><p><img src="https://youzhixueyuan.com/blog/wp-content/uploads/2019/08/20190801212341_70574.jpg" alt="img"></p><p><strong>Java线程具有五中基本状态</strong></p><p><strong>1）新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p><p><strong>2）就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p><p><strong>3）运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p><p><strong>4）阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p><p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p><p>2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p><p>3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时. join()等待线程终止或者超时. 或者I/O处理完毕时，线程重新转入就绪状态。</p><p><strong>5）死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h2 id="_3-什么是线程死锁-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#_3-什么是线程死锁-如何避免死锁" aria-hidden="true">#</a> 3. 什么是线程死锁?如何避免死锁?</h2><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><ul><li>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 <img src="http://blog-img.coolsen.cn/img/1583327022365_13.png" alt="img"></li></ul><h3 id="死锁必须具备以下四个条件" tabindex="-1"><a class="header-anchor" href="#死锁必须具备以下四个条件" aria-hidden="true">#</a> 死锁必须具备以下四个条件：</h3><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h3 id="如何避免线程死锁" tabindex="-1"><a class="header-anchor" href="#如何避免线程死锁" aria-hidden="true">#</a> 如何避免线程死锁?</h3><p>只要破坏产生死锁的四个条件中的其中一个就可以了</p><ul><li>破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）</li><li>破坏请求与保持条件 一次性申请所有的资源。</li><li>破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li><li>锁排序法：（必须回答出来的点） 指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？ 通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</li><li>使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁</li></ul><h2 id="_4-cas了解吗" tabindex="-1"><a class="header-anchor" href="#_4-cas了解吗" aria-hidden="true">#</a> 4. CAS了解吗？</h2><ul><li>CAS：全称 <code>Compare and swap</code>，即<strong>比较并交换</strong>，它是一条 <strong>CPU 同步原语</strong>。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于管理对共享数据的并发访问。</li><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：</li><li><ul><li>需要读写的内存值 V</li><li>旧的预期值 A</li><li>要修改的更新值 B</li></ul></li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作（他的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。）</li></ul><p>CAS 并发原语体现在 Java 语言中的 <code>sum.misc.Unsafe</code> 类中的各个方法。调用 Unsafe 类中的 CAS 方法， JVM 会帮助我们实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于 CAS是一种系统原语，<strong>原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的</strong>，<strong>在执行过程中不允许被中断</strong>，CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。</p><h2 id="_5-cas有什么缺陷" tabindex="-1"><a class="header-anchor" href="#_5-cas有什么缺陷" aria-hidden="true">#</a> 5. CAS有什么缺陷？</h2><p><img src="http://blog-img.coolsen.cn/img/1246845-20200728125438568-1459891419.png" alt="img"></p><p><strong>1. ABA 问题</strong></p><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><p>可以通过AtomicStampedReference<strong>解决ABA问题</strong>，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。</p><p><strong>2. 循环时间长开销</strong></p><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><p>很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~</p><p><strong>3. 只能保证一个变量的原子操作。</strong></p><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><p><strong>可以通过这两个方式解决这个问题</strong>：</p><ul><li>使用互斥锁来保证原子性；</li><li>将多个变量封装成对象，通过AtomicReference来保证原子性。</li></ul><h2 id="_6-synchronized-和-lock-有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-synchronized-和-lock-有什么区别" aria-hidden="true">#</a> 6. synchronized 和 Lock 有什么区别？</h2><ul><li>synchronized 可以给类. 方法. 代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h2 id="_7-synchronized的用法有哪些" tabindex="-1"><a class="header-anchor" href="#_7-synchronized的用法有哪些" aria-hidden="true">#</a> 7. synchronized的用法有哪些?</h2><ul><li>修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</li><li>修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ul><p>特别注意：</p><p>①如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁</p><p>②尽量不要使用 synchronized(String s) ,因为JVM中，字符串常量池具有缓冲功能</p><h2 id="_8-threadlocal是什么" tabindex="-1"><a class="header-anchor" href="#_8-threadlocal是什么" aria-hidden="true">#</a> 8. ThreadLocal是什么?</h2><p>ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//创建一个ThreadLocal变量</span>
<span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ThreadLocal的应用场景有</strong></p><ul><li>数据库连接池</li><li>会话管理中使用</li></ul><h2 id="_9-你说下线程池核心参数" tabindex="-1"><a class="header-anchor" href="#_9-你说下线程池核心参数" aria-hidden="true">#</a> 9. 你说下线程池核心参数？</h2><ul><li><p>corePoolSize ： 核心线程大小。线程池一直运行，核心线程就不会停止。</p></li><li><p>maximumPoolSize ：线程池最大线程数量。非核心线程数量=maximumPoolSize-corePoolSize</p></li><li><p>keepAliveTime ：非核心线程的心跳时间。如果非核心线程在keepAliveTime内没有运行任务，非核心线程会消亡。</p></li><li><p>workQueue ：阻塞队列。ArrayBlockingQueue，LinkedBlockingQueue等，用来存放线程任务。</p></li><li><p>defaultHandler ：饱和策略。ThreadPoolExecutor类中一共有4种饱和策略。通过实现</p><p>RejectedExecutionHandler</p><p>接口。</p><ul><li>AbortPolicy ： 线程任务丢弃报错。默认饱和策略。</li><li>DiscardPolicy ： 线程任务直接丢弃不报错。</li><li>DiscardOldestPolicy ： 将workQueue<strong>队首任务丢弃</strong>，将最新线程任务重新加入队列执行。</li><li>CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。</li></ul></li><li><p>ThreadFactory ：线程工厂。新建线程工厂。</p></li></ul><h2 id="_10-线程池执行任务的流程" tabindex="-1"><a class="header-anchor" href="#_10-线程池执行任务的流程" aria-hidden="true">#</a> 10. 线程池执行任务的流程？</h2><p><img src="http://blog-img.coolsen.cn/img/1460000039258685" alt="image.png"></p><ol><li>线程池执行execute/submit方法向线程池添加任务，当任务小于核心线程数corePoolSize，线程池中可以创建新的线程。</li><li>当任务大于核心线程数corePoolSize，就向阻塞队列添加任务。</li><li>如果阻塞队列已满，需要通过比较参数maximumPoolSize，在线程池创建新的线程，当线程数量大于maximumPoolSize，说明当前设置线程池中线程已经处理不了了，就会执行饱和策略。</li></ol><h2 id="_11-常用的java线程池有哪几种类型" tabindex="-1"><a class="header-anchor" href="#_11-常用的java线程池有哪几种类型" aria-hidden="true">#</a> 11. 常用的JAVA线程池有哪几种类型？</h2><p><strong>1、newCachedThreadPool</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>这种类型的线程池特点是：</p><p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p><p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</p><p><strong>2、newFixedThreadPool</strong></p><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><p><strong>3、newSingleThreadExecutor</strong></p><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><p><strong>4、newScheduleThreadPool</strong></p><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p><p>题目：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>. 创建线程的三种方式的对比？
<span class="token number">2</span>. 线程的状态流转
<span class="token number">3</span>. 什么是线程死锁?如何避免死锁?
<span class="token number">4</span>. CAS了解吗？
<span class="token number">5</span>. CAS有什么缺陷？
<span class="token number">6</span>. synchronized 和 Lock 有什么区别？
<span class="token number">7</span>. synchronized的用法有哪些?
<span class="token number">8</span>. ThreadLocal是什么?
<span class="token number">9</span>. 你说下线程池核心参数？
<span class="token number">10</span>. 线程池执行任务的流程？
<span class="token number">11</span>. 常用的JAVA线程池有哪几种类型？
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,82),r=[i];function o(t,p){return a(),e("div",null,r)}const d=n(l,[["render",o],["__file","interview8.html.vue"]]);export{d as default};
