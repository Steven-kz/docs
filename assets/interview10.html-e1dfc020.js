const l=JSON.parse('{"key":"v-8906bc00","path":"/interview/interview10.html","title":"无量心经","lang":"zh-CN","frontmatter":{"title":"无量心经"},"headers":[{"level":2,"title":"一 SpringCloud 微服务","slug":"一-springcloud-微服务","link":"#一-springcloud-微服务","children":[]},{"level":2,"title":"1 什么是微服务","slug":"_1-什么是微服务","link":"#_1-什么是微服务","children":[]},{"level":2,"title":"2 微服务框架的优势","slug":"_2-微服务框架的优势","link":"#_2-微服务框架的优势","children":[]},{"level":2,"title":"3 SpringCloud 和微服务的关系","slug":"_3-springcloud-和微服务的关系","link":"#_3-springcloud-和微服务的关系","children":[]},{"level":2,"title":"4 SpringBoot 和 SpringCloud 的区别","slug":"_4-springboot-和-springcloud-的区别","link":"#_4-springboot-和-springcloud-的区别","children":[]},{"level":2,"title":"5 什么是 CAP","slug":"_5-什么是-cap","link":"#_5-什么是-cap","children":[]},{"level":2,"title":"二 Naoca 注册中心","slug":"二-naoca-注册中心","link":"#二-naoca-注册中心","children":[]},{"level":2,"title":"三 Sentinel 熔断 / 降流","slug":"三-sentinel-熔断-降流","link":"#三-sentinel-熔断-降流","children":[]},{"level":2,"title":"2 怎么设置降流","slug":"_2-怎么设置降流","link":"#_2-怎么设置降流","children":[]},{"level":2,"title":"2 熔断","slug":"_2-熔断","link":"#_2-熔断","children":[]},{"level":2,"title":"四 Gateway 网关","slug":"四-gateway-网关","link":"#四-gateway-网关","children":[]},{"level":2,"title":"五 Seata 分布式事务","slug":"五-seata-分布式事务","link":"#五-seata-分布式事务","children":[{"level":3,"title":"1 什么是分布式事务","slug":"_1-什么是分布式事务","link":"#_1-什么是分布式事务","children":[]},{"level":3,"title":"2 而在seata中有AT、TCC、SAGA和 XA 事务模式","slug":"_2-而在seata中有at、tcc、saga和-xa-事务模式","link":"#_2-而在seata中有at、tcc、saga和-xa-事务模式","children":[]}]},{"level":2,"title":"六分布式锁","slug":"六分布式锁","link":"#六分布式锁","children":[]},{"level":2,"title":"一 RabbitMQ","slug":"一-rabbitmq","link":"#一-rabbitmq","children":[]},{"level":2,"title":"3  MQ 的模式有那些","slug":"_3-mq-的模式有那些","link":"#_3-mq-的模式有那些","children":[]},{"level":2,"title":"4  MQ 怎么确保消息的可靠性","slug":"_4-mq-怎么确保消息的可靠性","link":"#_4-mq-怎么确保消息的可靠性","children":[{"level":3,"title":"可以采用持久化机制+手动ACK","slug":"可以采用持久化机制-手动ack","link":"#可以采用持久化机制-手动ack","children":[]},{"level":3,"title":"1 开启持久化","slug":"_1-开启持久化","link":"#_1-开启持久化","children":[]}]},{"level":2,"title":"5  MQ 怎么避免消息重复消费（幂等性）","slug":"_5-mq-怎么避免消息重复消费-幂等性","link":"#_5-mq-怎么避免消息重复消费-幂等性","children":[]},{"level":2,"title":"6 怎么实现延迟队列","slug":"_6-怎么实现延迟队列","link":"#_6-怎么实现延迟队列","children":[{"level":3,"title":"TTL+ 死信队列","slug":"ttl-死信队列","link":"#ttl-死信队列","children":[]},{"level":3,"title":"通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能","slug":"通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能","link":"#通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能","children":[]}]},{"level":2,"title":"二 Redis （ NoSql ）","slug":"二-redis-nosql","link":"#二-redis-nosql","children":[]},{"level":2,"title":"1 为什么使用 redis ，使用 redis 的好处","slug":"_1-为什么使用-redis-使用-redis-的好处","link":"#_1-为什么使用-redis-使用-redis-的好处","children":[{"level":3,"title":"1 速度快，因为数据存储再内存中","slug":"_1-速度快-因为数据存储再内存中","link":"#_1-速度快-因为数据存储再内存中","children":[]}]},{"level":2,"title":"2  Rdb 和 Aof 的持久化机制","slug":"_2-rdb-和-aof-的持久化机制","link":"#_2-rdb-和-aof-的持久化机制","children":[{"level":3,"title":"持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失","slug":"持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失","link":"#持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失","children":[]}]},{"level":2,"title":"3 怎么保证 redis 和数据库的一致性","slug":"_3-怎么保证-redis-和数据库的一致性","link":"#_3-怎么保证-redis-和数据库的一致性","children":[{"level":3,"title":"1 合理的设置缓存过期时间","slug":"_1-合理的设置缓存过期时间","link":"#_1-合理的设置缓存过期时间","children":[]}]},{"level":2,"title":"4  redis 缓存穿透，缓存雪崩，缓存击穿","slug":"_4-redis-缓存穿透-缓存雪崩-缓存击穿","link":"#_4-redis-缓存穿透-缓存雪崩-缓存击穿","children":[]},{"level":2,"title":"5  redis 如何实现高并发、高可用","slug":"_5-redis-如何实现高并发、高可用","link":"#_5-redis-如何实现高并发、高可用","children":[{"level":3,"title":"高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发","slug":"高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发","link":"#高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发","children":[]},{"level":3,"title":"高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点","slug":"高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点","link":"#高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点","children":[]}]},{"level":2,"title":"6  redis 的性能优化，和解决方案","slug":"_6-redis-的性能优化-和解决方案","link":"#_6-redis-的性能优化-和解决方案","children":[]},{"level":2,"title":"7  redis 的 TrdLock 红锁的实现","slug":"_7-redis-的-trdlock-红锁的实现","link":"#_7-redis-的-trdlock-红锁的实现","children":[]},{"level":2,"title":"8  redis 的过期策略","slug":"_8-redis-的过期策略","link":"#_8-redis-的过期策略","children":[]},{"level":2,"title":"三 Mybatis","slug":"三-mybatis","link":"#三-mybatis","children":[]},{"level":2,"title":"1  mybatis 的优缺点","slug":"_1-mybatis-的优缺点","link":"#_1-mybatis-的优缺点","children":[{"level":3,"title":"优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性","slug":"优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性","link":"#优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性","children":[]}]},{"level":2,"title":"2  mybatis 的 1 ， 2 级缓存","slug":"_2-mybatis-的-1-2-级缓存","link":"#_2-mybatis-的-1-2-级缓存","children":[]},{"level":2,"title":"一 Spring","slug":"一-spring","link":"#一-spring","children":[]},{"level":2,"title":"1 为什么使用 spring","slug":"_1-为什么使用-spring","link":"#_1-为什么使用-spring","children":[]},{"level":2,"title":"2 什么是 Aop ， Ioc","slug":"_2-什么是-aop-ioc","link":"#_2-什么是-aop-ioc","children":[]},{"level":2,"title":"3  spring 的注入方式","slug":"_3-spring-的注入方式","link":"#_3-spring-的注入方式","children":[]},{"level":2,"title":"4  springBean 的声命周期","slug":"_4-springbean-的声命周期","link":"#_4-springbean-的声命周期","children":[]},{"level":2,"title":"5  spring 的自动装配","slug":"_5-spring-的自动装配","link":"#_5-spring-的自动装配","children":[{"level":3,"title":"容器不会自动装配","slug":"容器不会自动装配","link":"#容器不会自动装配","children":[]}]},{"level":2,"title":"6  spring 框架用到了那些设计模式","slug":"_6-spring-框架用到了那些设计模式","link":"#_6-spring-框架用到了那些设计模式","children":[]},{"level":2,"title":"7  spring 的事务性","slug":"_7-spring-的事务性","link":"#_7-spring-的事务性","children":[{"level":3,"title":"可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现","slug":"可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现","link":"#可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现","children":[]}]},{"level":2,"title":"二 SpringMVC","slug":"二-springmvc","link":"#二-springmvc","children":[]},{"level":2,"title":"1 什么是 springMvc","slug":"_1-什么是-springmvc","link":"#_1-什么是-springmvc","children":[]},{"level":2,"title":"2  MVC 有那些组件","slug":"_2-mvc-有那些组件","link":"#_2-mvc-有那些组件","children":[]},{"level":2,"title":"三 SpringBoot","slug":"三-springboot","link":"#三-springboot","children":[]},{"level":2,"title":"1 什么是 springBoot/ 你对 springBoot 的理解","slug":"_1-什么是-springboot-你对-springboot-的理解","link":"#_1-什么是-springboot-你对-springboot-的理解","children":[{"level":3,"title":"1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架","slug":"_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架","link":"#_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架","children":[]}]},{"level":2,"title":"2  springBoot 的配置","slug":"_2-springboot-的配置","link":"#_2-springboot-的配置","children":[]},{"level":2,"title":"3  SpringBootApplication 的作用","slug":"_3-springbootapplication-的作用","link":"#_3-springbootapplication-的作用","children":[{"level":3,"title":"放在启动了上、、、此注解中包含三个注解","slug":"放在启动了上、、、此注解中包含三个注解","link":"#放在启动了上、、、此注解中包含三个注解","children":[]}]},{"level":2,"title":"四 spring 、 springMVC 、 springBoot 区别","slug":"四-spring-、-springmvc-、-springboot-区别","link":"#四-spring-、-springmvc-、-springboot-区别","children":[]},{"level":2,"title":"一 sql 基础","slug":"一-sql-基础","link":"#一-sql-基础","children":[]},{"level":2,"title":"1  mysql 四大操作","slug":"_1-mysql-四大操作","link":"#_1-mysql-四大操作","children":[{"level":3,"title":"CRUD","slug":"crud","link":"#crud","children":[]}]},{"level":2,"title":"2  mysql 常用类型","slug":"_2-mysql-常用类型","link":"#_2-mysql-常用类型","children":[]},{"level":2,"title":"3  mysql 常用关键字","slug":"_3-mysql-常用关键字","link":"#_3-mysql-常用关键字","children":[]},{"level":2,"title":"4  mysql 常用函数","slug":"_4-mysql-常用函数","link":"#_4-mysql-常用函数","children":[{"level":3,"title":"聚合函数、日期函数、字符串函数、数值函数、流程控制函数","slug":"聚合函数、日期函数、字符串函数、数值函数、流程控制函数","link":"#聚合函数、日期函数、字符串函数、数值函数、流程控制函数","children":[]},{"level":3,"title":"1 聚合函数","slug":"_1-聚合函数","link":"#_1-聚合函数","children":[]},{"level":3,"title":"2 时间函数","slug":"_2-时间函数","link":"#_2-时间函数","children":[]}]},{"level":2,"title":"二 sql 事务","slug":"二-sql-事务","link":"#二-sql-事务","children":[]},{"level":2,"title":"1 数据库的三大范氏","slug":"_1-数据库的三大范氏","link":"#_1-数据库的三大范氏","children":[{"level":3,"title":"第一范氏：数据库的每一列都是不可分割的原子数据","slug":"第一范氏-数据库的每一列都是不可分割的原子数据","link":"#第一范氏-数据库的每一列都是不可分割的原子数据","children":[]},{"level":3,"title":"例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用","slug":"例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用","link":"#例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用","children":[]},{"level":3,"title":"第二范氏：实体的属性不能完全依赖于主关键字","slug":"第二范氏-实体的属性不能完全依赖于主关键字","link":"#第二范氏-实体的属性不能完全依赖于主关键字","children":[]},{"level":3,"title":"第三范氏：任何非主属性不依赖于其他主属性","slug":"第三范氏-任何非主属性不依赖于其他主属性","link":"#第三范氏-任何非主属性不依赖于其他主属性","children":[]},{"level":3,"title":"第四范氏：一张表中，尽量不要使用多对多的关系","slug":"第四范氏-一张表中-尽量不要使用多对多的关系","link":"#第四范氏-一张表中-尽量不要使用多对多的关系","children":[]},{"level":3,"title":"第五范氏：从最终结构重新建立原始结构","slug":"第五范氏-从最终结构重新建立原始结构","link":"#第五范氏-从最终结构重新建立原始结构","children":[]}]},{"level":2,"title":"2 事务的四大特性","slug":"_2-事务的四大特性","link":"#_2-事务的四大特性","children":[{"level":3,"title":"ACID","slug":"acid","link":"#acid","children":[]},{"level":3,"title":"时开启的同时互不干扰，相互隔离","slug":"时开启的同时互不干扰-相互隔离","link":"#时开启的同时互不干扰-相互隔离","children":[]}]},{"level":2,"title":"3 事务的并发问题","slug":"_3-事务的并发问题","link":"#_3-事务的并发问题","children":[{"level":3,"title":"1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到","slug":"_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到","link":"#_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到","children":[]},{"level":3,"title":"2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致","slug":"_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致","link":"#_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致","children":[]},{"level":3,"title":"3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致","slug":"_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致","link":"#_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致","children":[]}]},{"level":2,"title":"4 事务的隔离级别","slug":"_4-事务的隔离级别","link":"#_4-事务的隔离级别","children":[{"level":3,"title":"1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取","slug":"_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取","link":"#_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取","children":[]},{"level":3,"title":"解决了事务更新丢失，但是会出现脏读","slug":"解决了事务更新丢失-但是会出现脏读","link":"#解决了事务更新丢失-但是会出现脏读","children":[]},{"level":3,"title":"2 读提交：第一个事务读取，其他数据可以进行读写操作","slug":"_2-读提交-第一个事务读取-其他数据可以进行读写操作","link":"#_2-读提交-第一个事务读取-其他数据可以进行读写操作","children":[]},{"level":3,"title":"解决了事务更新丢失，脏读，但是可能出现不可重复读","slug":"解决了事务更新丢失-脏读-但是可能出现不可重复读","link":"#解决了事务更新丢失-脏读-但是可能出现不可重复读","children":[]},{"level":3,"title":"3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写","slug":"_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写","link":"#_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写","children":[]},{"level":3,"title":"解决了事务更新丢失，脏读，不可重复读，但是会出现幻读","slug":"解决了事务更新丢失-脏读-不可重复读-但是会出现幻读","link":"#解决了事务更新丢失-脏读-不可重复读-但是会出现幻读","children":[]},{"level":3,"title":"4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行）","slug":"_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行","link":"#_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行","children":[]},{"level":3,"title":"解决了事务更新丢失，脏读，不可重复的，幻读","slug":"解决了事务更新丢失-脏读-不可重复的-幻读","link":"#解决了事务更新丢失-脏读-不可重复的-幻读","children":[]},{"level":3,"title":"事务排队执行，但是性能低，一般不会被使用","slug":"事务排队执行-但是性能低-一般不会被使用","link":"#事务排队执行-但是性能低-一般不会被使用","children":[]}]},{"level":2,"title":"三 sql 索引","slug":"三-sql-索引","link":"#三-sql-索引","children":[]},{"level":2,"title":"1 什么是索引","slug":"_1-什么是索引","link":"#_1-什么是索引","children":[{"level":3,"title":"索引是数据库的一个排序的数据结构，索引使用B树，B+树实现","slug":"索引是数据库的一个排序的数据结构-索引使用b树-b-树实现","link":"#索引是数据库的一个排序的数据结构-索引使用b树-b-树实现","children":[]}]},{"level":2,"title":"2 索引的作用","slug":"_2-索引的作用","link":"#_2-索引的作用","children":[{"level":3,"title":"快速查找，更新表中数据","slug":"快速查找-更新表中数据","link":"#快速查找-更新表中数据","children":[]},{"level":3,"title":"代价：数据库存储空间增加，插入和修改花费时间较多","slug":"代价-数据库存储空间增加-插入和修改花费时间较多","link":"#代价-数据库存储空间增加-插入和修改花费时间较多","children":[]}]},{"level":2,"title":"3 索引的分类","slug":"_3-索引的分类","link":"#_3-索引的分类","children":[{"level":3,"title":"1 普通索引：仅加速查询","slug":"_1-普通索引-仅加速查询","link":"#_1-普通索引-仅加速查询","children":[]}]},{"level":2,"title":"4 索引的优缺点","slug":"_4-索引的优缺点","link":"#_4-索引的优缺点","children":[{"level":3,"title":"优点：可以大大的提升性能","slug":"优点-可以大大的提升性能","link":"#优点-可以大大的提升性能","children":[]},{"level":3,"title":"1 唯一索引：可以保证每一行数据的唯一性","slug":"_1-唯一索引-可以保证每一行数据的唯一性","link":"#_1-唯一索引-可以保证每一行数据的唯一性","children":[]},{"level":3,"title":"2 提升了数据的检索速度","slug":"_2-提升了数据的检索速度","link":"#_2-提升了数据的检索速度","children":[]},{"level":3,"title":"3 可以加速表与表之间的连接","slug":"_3-可以加速表与表之间的连接","link":"#_3-可以加速表与表之间的连接","children":[]},{"level":3,"title":"4 查询速度快","slug":"_4-查询速度快","link":"#_4-查询速度快","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]},{"level":3,"title":"1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度","slug":"_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度","link":"#_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度","children":[]},{"level":3,"title":"2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大）","slug":"_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大","link":"#_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大","children":[]},{"level":3,"title":"3 维护索引时间增加","slug":"_3-维护索引时间增加","link":"#_3-维护索引时间增加","children":[]}]},{"level":2,"title":"5  B 树和 B+ 树","slug":"_5-b-树和-b-树","link":"#_5-b-树和-b-树","children":[]},{"level":2,"title":"四 mysql 的存储引擎","slug":"四-mysql-的存储引擎","link":"#四-mysql-的存储引擎","children":[]},{"level":2,"title":"1  mysql 的存储引擎有那些","slug":"_1-mysql-的存储引擎有那些","link":"#_1-mysql-的存储引擎有那些","children":[]},{"level":2,"title":"2  mysql 的存储过程","slug":"_2-mysql-的存储过程","link":"#_2-mysql-的存储过程","children":[{"level":3,"title":"存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用","slug":"存储过程-预编译模式-只创建一次-后续在程序中可以多次调用","link":"#存储过程-预编译模式-只创建一次-后续在程序中可以多次调用","children":[]},{"level":3,"title":"1 可以使用一个命令对象调用存储过程","slug":"_1-可以使用一个命令对象调用存储过程","link":"#_1-可以使用一个命令对象调用存储过程","children":[]}]},{"level":2,"title":"3 存储过程的优缺点","slug":"_3-存储过程的优缺点","link":"#_3-存储过程的优缺点","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"1 存储过程是预编译过的，执行效率高","slug":"_1-存储过程是预编译过的-执行效率高","link":"#_1-存储过程是预编译过的-执行效率高","children":[]},{"level":3,"title":"2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信）","slug":"_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信","link":"#_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信","children":[]},{"level":3,"title":"3 安全性高，需要有一定权限的用户执行","slug":"_3-安全性高-需要有一定权限的用户执行","link":"#_3-安全性高-需要有一定权限的用户执行","children":[]},{"level":3,"title":"4 可以重复使用，减少代码量","slug":"_4-可以重复使用-减少代码量","link":"#_4-可以重复使用-减少代码量","children":[]},{"level":3,"title":"缺点：移植性差","slug":"缺点-移植性差","link":"#缺点-移植性差","children":[]}]},{"level":2,"title":"五 sql 优化","slug":"五-sql-优化","link":"#五-sql-优化","children":[]},{"level":2,"title":"1 怎么查找需要优化的数据","slug":"_1-怎么查找需要优化的数据","link":"#_1-怎么查找需要优化的数据","children":[{"level":3,"title":"定位——分析——解决","slug":"定位——分析——解决","link":"#定位——分析——解决","children":[]}]},{"level":2,"title":"一内存","slug":"一内存","link":"#一内存","children":[]},{"level":2,"title":"1 类加载的过程","slug":"_1-类加载的过程","link":"#_1-类加载的过程","children":[{"level":3,"title":"加载——校验——准备——解析——初始化——使用——卸载","slug":"加载——校验——准备——解析——初始化——使用——卸载","link":"#加载——校验——准备——解析——初始化——使用——卸载","children":[]}]},{"level":2,"title":"2  java 中类的声明周期","slug":"_2-java-中类的声明周期","link":"#_2-java-中类的声明周期","children":[{"level":3,"title":"加载——连接——初始化——使用——卸载","slug":"加载——连接——初始化——使用——卸载","link":"#加载——连接——初始化——使用——卸载","children":[]}]},{"level":2,"title":"3 什么是双亲委派模型","slug":"_3-什么是双亲委派模型","link":"#_3-什么是双亲委派模型","children":[{"level":3,"title":"双亲委派模型是一个类的加载过程","slug":"双亲委派模型是一个类的加载过程","link":"#双亲委派模型是一个类的加载过程","children":[]},{"level":3,"title":"一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父","slug":"一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父","link":"#一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父","children":[]},{"level":3,"title":"加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载","slug":"加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载","link":"#加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载","children":[]},{"level":3,"title":"优点：防止内存中出现多份同样的字节码","slug":"优点-防止内存中出现多份同样的字节码","link":"#优点-防止内存中出现多份同样的字节码","children":[]}]},{"level":2,"title":"4 堆和栈道区别","slug":"_4-堆和栈道区别","link":"#_4-堆和栈道区别","children":[{"level":3,"title":"栈：内存用来存储局部变量和方法的调用","slug":"栈-内存用来存储局部变量和方法的调用","link":"#栈-内存用来存储局部变量和方法的调用","children":[]}]},{"level":2,"title":"二 CG 算法","slug":"二-cg-算法","link":"#二-cg-算法","children":[]},{"level":2,"title":"1  JVM 有那些垃圾回收算法","slug":"_1-jvm-有那些垃圾回收算法","link":"#_1-jvm-有那些垃圾回收算法","children":[{"level":3,"title":"标记-清除算法——标记-整理算法——复制算法——分代算法","slug":"标记-清除算法——标记-整理算法——复制算法——分代算法","link":"#标记-清除算法——标记-整理算法——复制算法——分代算法","children":[]},{"level":3,"title":"1 标记-清除算法：标记无用的对象，然后进行清除回收","slug":"_1-标记-清除算法-标记无用的对象-然后进行清除回收","link":"#_1-标记-清除算法-标记无用的对象-然后进行清除回收","children":[]},{"level":3,"title":"缺点：效率不高，无法清除垃圾碎片","slug":"缺点-效率不高-无法清除垃圾碎片","link":"#缺点-效率不高-无法清除垃圾碎片","children":[]},{"level":3,"title":"2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存","slug":"_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存","link":"#_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存","children":[]},{"level":3,"title":"3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后","slug":"_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后","link":"#_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后","children":[]},{"level":3,"title":"将或者的对象复制到另一个区域中，再清除用完的区域","slug":"将或者的对象复制到另一个区域中-再清除用完的区域","link":"#将或者的对象复制到另一个区域中-再清除用完的区域","children":[]},{"level":3,"title":"缺点：内存使用率低，只有原来的一般空间","slug":"缺点-内存使用率低-只有原来的一般空间","link":"#缺点-内存使用率低-只有原来的一般空间","children":[]},{"level":3,"title":"4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代","slug":"_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代","link":"#_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代","children":[]},{"level":3,"title":"新生代一般采用复制算法，老年代一般采用标记整理算法","slug":"新生代一般采用复制算法-老年代一般采用标记整理算法","link":"#新生代一般采用复制算法-老年代一般采用标记整理算法","children":[]}]},{"level":2,"title":"2  JVM 的垃圾回收器","slug":"_2-jvm-的垃圾回收器","link":"#_2-jvm-的垃圾回收器","children":[{"level":3,"title":"常用：CMS、G 1","slug":"常用-cms、g-1","link":"#常用-cms、g-1","children":[]}]},{"level":2,"title":"3  CMS 垃圾回收器","slug":"_3-cms-垃圾回收器","link":"#_3-cms-垃圾回收器","children":[{"level":3,"title":"CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片","slug":"cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片","link":"#cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片","children":[]}]},{"level":2,"title":"4 新生代和老年代的垃圾回收期有哪些，有什么区别","slug":"_4-新生代和老年代的垃圾回收期有哪些-有什么区别","link":"#_4-新生代和老年代的垃圾回收期有哪些-有什么区别","children":[]},{"level":2,"title":"5 垃圾回收器是怎么工作的","slug":"_5-垃圾回收器是怎么工作的","link":"#_5-垃圾回收器是怎么工作的","children":[{"level":3,"title":"分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间）","slug":"分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间","link":"#分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间","children":[]},{"level":3,"title":"1 新生代：使用的是复制算法","slug":"_1-新生代-使用的是复制算法","link":"#_1-新生代-使用的是复制算法","children":[]},{"level":3,"title":"2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法","slug":"_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法","link":"#_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法","children":[]}]},{"level":2,"title":"6  java 中有那些引用类型","slug":"_6-java-中有那些引用类型","link":"#_6-java-中有那些引用类型","children":[{"level":3,"title":"强引用——软引用——弱引用——虚引用","slug":"强引用——软引用——弱引用——虚引用","link":"#强引用——软引用——弱引用——虚引用","children":[]},{"level":3,"title":"1 强引用：发生GC时不会被回收","slug":"_1-强引用-发生gc时不会被回收","link":"#_1-强引用-发生gc时不会被回收","children":[]},{"level":3,"title":"2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收","slug":"_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收","link":"#_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收","children":[]},{"level":3,"title":"3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收","slug":"_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收","link":"#_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收","children":[]},{"level":3,"title":"4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知","slug":"_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知","link":"#_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知","children":[]}]},{"level":2,"title":"7  GC 的触发条件","slug":"_7-gc-的触发条件","link":"#_7-gc-的触发条件","children":[{"level":3,"title":"老年区空间不足、方法区空间不足、","slug":"老年区空间不足、方法区空间不足、","link":"#老年区空间不足、方法区空间不足、","children":[]},{"level":3,"title":"当复制算法等，进入老年代时平均大小大于老年代的空间时","slug":"当复制算法等-进入老年代时平均大小大于老年代的空间时","link":"#当复制算法等-进入老年代时平均大小大于老年代的空间时","children":[]}]},{"level":2,"title":"一线程","slug":"一线程","link":"#一线程","children":[]},{"level":2,"title":"1 进程和线程的区别","slug":"_1-进程和线程的区别","link":"#_1-进程和线程的区别","children":[{"level":3,"title":"进程：应用程序执行的实例，有独立的内存空间和系统资源","slug":"进程-应用程序执行的实例-有独立的内存空间和系统资源","link":"#进程-应用程序执行的实例-有独立的内存空间和系统资源","children":[]},{"level":3,"title":"线程：CPU调度和分派的基本单位，应用程序是最小的单位","slug":"线程-cpu调度和分派的基本单位-应用程序是最小的单位","link":"#线程-cpu调度和分派的基本单位-应用程序是最小的单位","children":[]}]},{"level":2,"title":"2 线程的状态","slug":"_2-线程的状态","link":"#_2-线程的状态","children":[{"level":3,"title":"创建线程——就绪状态——运行状态——阻塞状态——死亡状态","slug":"创建线程——就绪状态——运行状态——阻塞状态——死亡状态","link":"#创建线程——就绪状态——运行状态——阻塞状态——死亡状态","children":[]}]},{"level":2,"title":"3 常用方法（调度）","slug":"_3-常用方法-调度","link":"#_3-常用方法-调度","children":[]},{"level":2,"title":"4 线程的有点","slug":"_4-线程的有点","link":"#_4-线程的有点","children":[{"level":3,"title":"1 可重复使用存在的线程，减少对象创建销毁的开销","slug":"_1-可重复使用存在的线程-减少对象创建销毁的开销","link":"#_1-可重复使用存在的线程-减少对象创建销毁的开销","children":[]},{"level":3,"title":"2 提高系统资源的使用率，避免多资源竞争，避免阻塞","slug":"_2-提高系统资源的使用率-避免多资源竞争-避免阻塞","link":"#_2-提高系统资源的使用率-避免多资源竞争-避免阻塞","children":[]},{"level":3,"title":"3 提供定时，定期执行，单线程、并发等控制功能","slug":"_3-提供定时-定期执行-单线程、并发等控制功能","link":"#_3-提供定时-定期执行-单线程、并发等控制功能","children":[]}]},{"level":2,"title":"5 实现多线程的几种方法","slug":"_5-实现多线程的几种方法","link":"#_5-实现多线程的几种方法","children":[]},{"level":2,"title":"6 创建线程池的几种方法","slug":"_6-创建线程池的几种方法","link":"#_6-创建线程池的几种方法","children":[]},{"level":2,"title":"7 线程池的状态","slug":"_7-线程池的状态","link":"#_7-线程池的状态","children":[]},{"level":2,"title":"8 线程池中 submit （）和 execute 的区别","slug":"_8-线程池中-submit-和-execute-的区别","link":"#_8-线程池中-submit-和-execute-的区别","children":[]},{"level":2,"title":"9 线程池的七大核心参数","slug":"_9-线程池的七大核心参数","link":"#_9-线程池的七大核心参数","children":[]},{"level":2,"title":"二线程安全","slug":"二线程安全","link":"#二线程安全","children":[]},{"level":2,"title":"1  Java 中怎么保证线程的安全","slug":"_1-java-中怎么保证线程的安全","link":"#_1-java-中怎么保证线程的安全","children":[]},{"level":2,"title":"2 什么是死锁，怎么防止","slug":"_2-什么是死锁-怎么防止","link":"#_2-什么是死锁-怎么防止","children":[{"level":3,"title":"死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进","slug":"死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进","link":"#死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进","children":[]},{"level":3,"title":"就会造成死锁","slug":"就会造成死锁","link":"#就会造成死锁","children":[]}]},{"level":2,"title":"3  synchronized 的底层实现原理","slug":"_3-synchronized-的底层实现原理","link":"#_3-synchronized-的底层实现原理","children":[{"level":3,"title":"每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候","slug":"每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候","link":"#每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候","children":[]},{"level":3,"title":"尝试获取锁的每个对象","slug":"尝试获取锁的每个对象","link":"#尝试获取锁的每个对象","children":[]}]},{"level":2,"title":"4  synchronized 和 lock 的区别","slug":"_4-synchronized-和-lock-的区别","link":"#_4-synchronized-和-lock-的区别","children":[]},{"level":2,"title":"5 锁的类别","slug":"_5-锁的类别","link":"#_5-锁的类别","children":[]},{"level":2,"title":"一容器","slug":"一容器","link":"#一容器","children":[]},{"level":2,"title":"1  java 中有那些容器","slug":"_1-java-中有那些容器","link":"#_1-java-中有那些容器","children":[]},{"level":2,"title":"2 5 大容器的特点、用法","slug":"_2-5-大容器的特点、用法","link":"#_2-5-大容器的特点、用法","children":[]},{"level":2,"title":"3 那些容器是安全的，那些不安全","slug":"_3-那些容器是安全的-那些不安全","link":"#_3-那些容器是安全的-那些不安全","children":[]},{"level":2,"title":"二 java 基础","slug":"二-java-基础","link":"#二-java-基础","children":[]},{"level":2,"title":"1  Sring 的常用方法","slug":"_1-sring-的常用方法","link":"#_1-sring-的常用方法","children":[]},{"level":2,"title":"2  final 关键字","slug":"_2-final-关键字","link":"#_2-final-关键字","children":[{"level":3,"title":"修饰类：不能被继承","slug":"修饰类-不能被继承","link":"#修饰类-不能被继承","children":[]},{"level":3,"title":"修饰方法：不能被重写","slug":"修饰方法-不能被重写","link":"#修饰方法-不能被重写","children":[]},{"level":3,"title":"修饰变量：不能被修改","slug":"修饰变量-不能被修改","link":"#修饰变量-不能被修改","children":[]}]},{"level":2,"title":"3 方法重写和重载","slug":"_3-方法重写和重载","link":"#_3-方法重写和重载","children":[{"level":3,"title":"重写：参数名、方法名、返回值必须保持一致","slug":"重写-参数名、方法名、返回值必须保持一致","link":"#重写-参数名、方法名、返回值必须保持一致","children":[]}]},{"level":2,"title":"4  StringBuilder 、 StringBuffer 区别","slug":"_4-stringbuilder-、-stringbuffer-区别","link":"#_4-stringbuilder-、-stringbuffer-区别","children":[]},{"level":2,"title":"5 为什么重写 equals 必须重写 hashCode 方法","slug":"_5-为什么重写-equals-必须重写-hashcode-方法","link":"#_5-为什么重写-equals-必须重写-hashcode-方法","children":[]},{"level":2,"title":"6 数组在内存中如何分配","slug":"_6-数组在内存中如何分配","link":"#_6-数组在内存中如何分配","children":[]},{"level":2,"title":"7  java 中的四大引用类型","slug":"_7-java-中的四大引用类型","link":"#_7-java-中的四大引用类型","children":[{"level":3,"title":"强引用——软引用——弱引用——虚引用","slug":"强引用——软引用——弱引用——虚引用-1","link":"#强引用——软引用——弱引用——虚引用-1","children":[]}]}],"git":{"updatedTime":1678630251000,"contributors":[{"name":"knightbreeze1","email":"knightbreeze@163.com","commits":1}]},"filePathRelative":"interview/interview10.md"}');export{l as data};
