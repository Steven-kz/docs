import{_ as a,p as e,q as r,a1 as i}from"./framework-5866ffd3.js";const d={},h=i(`<h1 id="_1-微服务" tabindex="-1"><a class="header-anchor" href="#_1-微服务" aria-hidden="true">#</a> 1 微服务</h1><h2 id="一-springcloud-微服务" tabindex="-1"><a class="header-anchor" href="#一-springcloud-微服务" aria-hidden="true">#</a> 一 SpringCloud 微服务</h2><h2 id="_1-什么是微服务" tabindex="-1"><a class="header-anchor" href="#_1-什么是微服务" aria-hidden="true">#</a> 1 什么是微服务</h2><blockquote><p>微服务是一种架构思想，，，它是有多个组件组合而成---&gt;</p><p>任何一个微服务都是一个独立的进程（独立开发、独立维护、独立部署等）。。</p></blockquote><h2 id="_2-微服务框架的优势" tabindex="-1"><a class="header-anchor" href="#_2-微服务框架的优势" aria-hidden="true">#</a> 2 微服务框架的优势</h2><blockquote><p>1 一个微服务只关注一个特定的业务功能，业务清晰，代码量少。</p><p>开发和维护相对简单。</p><p>（整个应用是由若干个微服务构建而成 所以整个应用也在可控状态）</p><p>2 单个微服务代码量少，启动快</p><p>3 技术栈不受限制，每个小微服务都有他合理的技术栈</p></blockquote><h2 id="_3-springcloud-和微服务的关系" tabindex="-1"><a class="header-anchor" href="#_3-springcloud-和微服务的关系" aria-hidden="true">#</a> 3 SpringCloud 和微服务的关系</h2><blockquote><p>springCloud是一系列框架的集合体 nacos注册中心 Sentinel 熔断/降流 Gateway网关 Sleuth 链路追踪 Seata 分布式事务 Redisson---Redlock分布式锁</p></blockquote><h2 id="_4-springboot-和-springcloud-的区别" tabindex="-1"><a class="header-anchor" href="#_4-springboot-和-springcloud-的区别" aria-hidden="true">#</a> 4 SpringBoot 和 SpringCloud 的区别</h2><p>1 SpringBoot专注于开发单体项目</p><p>2 SpringCloud 专注于微服务的协调、整理、治理的框架，，它将SpringBoot开发的单体 项目联合管理起来</p><p>3 springBoot可以单体开发，，，SpringCloud不能离开SpringBoot开发，，属于依赖关系</p><h2 id="_5-什么是-cap" tabindex="-1"><a class="header-anchor" href="#_5-什么是-cap" aria-hidden="true">#</a> 5 什么是 CAP</h2><p>Consistency（一致性）、Availability（可用性）、Partitiontolerance(分区容忍性) 1 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是一样的值 （所有节点访问的都是同一分，最新的数据副本）</p><p>2 可用性（A）：在集群中一部分节点故障后，集群整体是否还能正常使用 （对数据更新具备，高可用性）</p><p>3 分区容忍性（P）：相当于队通信段时间限制 ，如果时间不能在时限内达到一致性，就 会发生分区的情况，，（必须在C，A之间做出选择）</p><p>CAP只能同时满足两个 取舍： 1 如果保证强一致性 采用 CA 放弃P 系统的扩展性降低（mysql采用CA模式）</p><p>2 如果不保证A采用CP的情况下 P的分区会无限延长，可能会造成数据丢失（故障）（Reids）</p><p>3 AP模式 放弃C的一致性，一旦放生分区，数据就会不一致（抢购活动）</p><h2 id="二-naoca-注册中心" tabindex="-1"><a class="header-anchor" href="#二-naoca-注册中心" aria-hidden="true">#</a> 二 Naoca 注册中心</h2><p>1 为什么使用 Nacos</p><blockquote><p>首先，服务器越来越多，不方便维护和管理，也容易造成代码冲突</p><p>可以将配置信息都交由nacos进行集中管理，，统一分配，</p><p>同时启动类上需要加上 @EnableDiscoveryClient 开启服务的注册与发现功能</p></blockquote><h2 id="三-sentinel-熔断-降流" tabindex="-1"><a class="header-anchor" href="#三-sentinel-熔断-降流" aria-hidden="true">#</a> 三 Sentinel 熔断 / 降流</h2><p>什么是熔断，什么是降流</p><blockquote><p>1 熔断：指的是我调用别人，出现了问题，怎么办，返回什么数据，报错等，</p><p>2 降流：指别人调用我请求量太大的话，需要对其限流</p></blockquote><h2 id="_2-怎么设置降流" tabindex="-1"><a class="header-anchor" href="#_2-怎么设置降流" aria-hidden="true">#</a> 2 怎么设置降流</h2><blockquote><p>1 流量监控其原理是 受监控应用流量的被设置的QPS到达指定的阔值的时候 对其进行流量控制，避免瞬间被大批的流量冲垮， 保障了应用的可用性</p><p>使用@SentinelResource的blockHandler可以指定限流后的异常处理方法</p></blockquote><h2 id="_2-熔断" tabindex="-1"><a class="header-anchor" href="#_2-熔断" aria-hidden="true">#</a> 2 熔断</h2><p>在我们 一个服务调用另一个服务如果出现了异常 或其他特殊情况的话 会进行熔断处理</p><blockquote><p>1 一段熔断，断路器的状态是Open打开的</p><p>2 当熔断时间结束后，断路器的状态时 half-Open（可以允许一个进来）</p><p>3 如果接下啦的请求正常的话 断路器的状态是 close （资源就自恢复），</p><p>4 如果失败，断路器的状态还是Open</p><p>使用@SentinelResource的fallBack可以指定熔断后的异常处理方法</p></blockquote><h2 id="四-gateway-网关" tabindex="-1"><a class="header-anchor" href="#四-gateway-网关" aria-hidden="true">#</a> 四 Gateway 网关</h2><p>为什么使用 Gateway 网关</p><blockquote><p>1 可以对微服务系统起到很好的性能优化</p><p>2 Gateway网关可以起到很好的作用，比如：路由、过滤、限流、监控等。。</p></blockquote><h2 id="五-seata-分布式事务" tabindex="-1"><a class="header-anchor" href="#五-seata-分布式事务" aria-hidden="true">#</a> 五 Seata 分布式事务</h2><h3 id="_1-什么是分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-什么是分布式事务" aria-hidden="true">#</a> 1 什么是分布式事务</h3><p>1 在spring中声明事务 通过spring的AOP实现 @TranSactional 中的rollbackFor、notRoolbackFor来实现事务的提交、回滚等</p><p>单服务的情况下 是一个service去访问两个不同的数据库</p><p>在多服务的进程中 可能有多个service 来回调用 来同时访问不同的数据库</p><p>在分布式事务中，它也是遵循了ACID的规范 原子性：要么全部成功，要么全部失败</p><p>一致性：从事务开始-到事务结束，数据库的完整性没有被破坏</p><p>隔离性：在多个事务并行进行 读写、修改等操作是不会交叉而导致数据不一致，</p><p>持久性：事务结束后，对数据的修改是永久性的，不会因为系统故障而造成数据丢失。</p><h3 id="_2-而在seata中有at、tcc、saga和-xa-事务模式" tabindex="-1"><a class="header-anchor" href="#_2-而在seata中有at、tcc、saga和-xa-事务模式" aria-hidden="true">#</a> 2 而在seata中有AT、TCC、SAGA和 XA 事务模式</h3><p>AT模式两阶段提交协议的演变：</p><p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。 二阶段： 提交异步化，非常快速地完成。 回滚通过一阶段的回滚日志进行反向补偿。</p><p>TCC编程模式：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存， Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。</p><h2 id="六分布式锁" tabindex="-1"><a class="header-anchor" href="#六分布式锁" aria-hidden="true">#</a> 六分布式锁</h2><p>可以使用Redisson中的RedLock锁来实现分布式锁</p><p>《RedLock是基于redis实现的分布式锁，它能够保证以下特性》 互斥锁：在任何时候只能有一个客户端持有锁 避免死锁：当客户拿到锁之后，即便是发生了异常或者服务器宕机的情况下， 利用key的存活时间避免死锁</p><h1 id="_2-中间键" tabindex="-1"><a class="header-anchor" href="#_2-中间键" aria-hidden="true">#</a> 2 中间键</h1><h2 id="一-rabbitmq" tabindex="-1"><a class="header-anchor" href="#一-rabbitmq" aria-hidden="true">#</a> 一 RabbitMQ</h2><p>1 什么是 MQ</p><blockquote><p>mq是通过异步发送消息的方式 使流量削峰，解耦，订单处理等问题</p></blockquote><p>2 MQ 的执行流程</p><blockquote><p>管道---生产者---交换机---路由---队列---消费者</p><p>先建立管道从生产者发送消息 到交换机，再从交换机路由到队列，最终到达消费者</p></blockquote><h2 id="_3-mq-的模式有那些" tabindex="-1"><a class="header-anchor" href="#_3-mq-的模式有那些" aria-hidden="true">#</a> 3 MQ 的模式有那些</h2><blockquote><p>1 点对点模式：点对点模式，从发送消息 到接收消息只有一个消费者</p><p>2 工作队列模式：一个队列有多个消费者，但最终只有一个消费者可以接收到消息</p><p>3 发布订阅模式：多对多，多个队列 到多个消费者</p><p>4 路由模式：可以规定消费者</p><p>注解@RabbitListener queuesToDeclare声明队列</p></blockquote><h2 id="_4-mq-怎么确保消息的可靠性" tabindex="-1"><a class="header-anchor" href="#_4-mq-怎么确保消息的可靠性" aria-hidden="true">#</a> 4 MQ 怎么确保消息的可靠性</h2><h3 id="可以采用持久化机制-手动ack" tabindex="-1"><a class="header-anchor" href="#可以采用持久化机制-手动ack" aria-hidden="true">#</a> 可以采用持久化机制+手动ACK</h3><h3 id="_1-开启持久化" tabindex="-1"><a class="header-anchor" href="#_1-开启持久化" aria-hidden="true">#</a> 1 开启持久化</h3><p>交换器和队列的持久化都是通过在声明时将durable参数置为true实现的 消息的持久化是在发送消息指定deliveryMode为 2 实现的</p><p>2 手动开启Ack模式</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>通过手动创建Bean重写SimpleMessageListenerContainer接口
newSimpleMessageListenerContainer将setAcknowledgeMode重新赋值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3 开启RabbitMQ的持久化。当生产者把消息成功写入RabbitMQ之后，RabbitMQ 就把消息持久化到磁盘。只有当消息成功持久化磁盘之后， 才会回调生产者的接口返回ack消息，否则都算失败，生产者会重新发送。存入磁盘的消息 不会丢失，就算RabbitMQ挂掉了，重启之后，他会读取磁盘中的消息，不会导致消息的丢 失。</p><h2 id="_5-mq-怎么避免消息重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_5-mq-怎么避免消息重复消费-幂等性" aria-hidden="true">#</a> 5 MQ 怎么避免消息重复消费（幂等性）</h2><p>1 可以使用redis的zset类型将消息的id放到redis中， 当ack失败后，再mq将消息传给其他消费者时，先执行setnx查询 如果key存在的话 什么都不做 如果不存在再 ack</p><p>（如果出现死锁的问题的话，再setnx上设置过期时间） （因为set集合就是自动有去重的）</p><h2 id="_6-怎么实现延迟队列" tabindex="-1"><a class="header-anchor" href="#_6-怎么实现延迟队列" aria-hidden="true">#</a> 6 怎么实现延迟队列</h2><h3 id="ttl-死信队列" tabindex="-1"><a class="header-anchor" href="#ttl-死信队列" aria-hidden="true">#</a> TTL+ 死信队列</h3><h3 id="通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" tabindex="-1"><a class="header-anchor" href="#通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" aria-hidden="true">#</a> 通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能</h3><h2 id="二-redis-nosql" tabindex="-1"><a class="header-anchor" href="#二-redis-nosql" aria-hidden="true">#</a> 二 Redis （ NoSql ）</h2><h2 id="_1-为什么使用-redis-使用-redis-的好处" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用-redis-使用-redis-的好处" aria-hidden="true">#</a> 1 为什么使用 redis ，使用 redis 的好处</h2><h3 id="_1-速度快-因为数据存储再内存中" tabindex="-1"><a class="header-anchor" href="#_1-速度快-因为数据存储再内存中" aria-hidden="true">#</a> 1 速度快，因为数据存储再内存中</h3><p>2 redis支持String，list，set，zset，hash ，sorted类型的存储</p><p>3 redis还支持事务，redis的操作都是原子性的，要么全部成功，要么全部失败</p><p>4 可用于缓存，设置key的存储时间</p><p>5 reids还支持数据的持久化，比如rdb和aof模式</p><p>6 reids还有redisson的TryLock锁 实现分布式锁功能</p><h2 id="_2-rdb-和-aof-的持久化机制" tabindex="-1"><a class="header-anchor" href="#_2-rdb-和-aof-的持久化机制" aria-hidden="true">#</a> 2 Rdb 和 Aof 的持久化机制</h2><h3 id="持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" tabindex="-1"><a class="header-anchor" href="#持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" aria-hidden="true">#</a> 持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失</h3><p>1 Rdb：指定的时间间隔能将你的数据进行快照存储 （如果本次快照刚存储完，下次快照还没存储的时候，服务器宕机了，中间这些数据会丢失）</p><p>2 Aof：每一次收到存储的命令都会用过write函数追加到文件中</p><p>Aof比rdb要更安全，更大 Aof更新频率高 Rdb 性能好</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（如果两者同时开启，会优先使用Aof）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_3-怎么保证-redis-和数据库的一致性" tabindex="-1"><a class="header-anchor" href="#_3-怎么保证-redis-和数据库的一致性" aria-hidden="true">#</a> 3 怎么保证 redis 和数据库的一致性</h2><h3 id="_1-合理的设置缓存过期时间" tabindex="-1"><a class="header-anchor" href="#_1-合理的设置缓存过期时间" aria-hidden="true">#</a> 1 合理的设置缓存过期时间</h3><p>2 增删改数据库的同时，同步更新redis， 可以采用事务的机制来保证数据的一致性</p><p>如果有大量的写数据 同时操作时可以间隔一段时间在同步到MySQL中</p><p>或者使用 alibaba的binlog框架实现</p><h2 id="_4-redis-缓存穿透-缓存雪崩-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_4-redis-缓存穿透-缓存雪崩-缓存击穿" aria-hidden="true">#</a> 4 redis 缓存穿透，缓存雪崩，缓存击穿</h2><p>1 缓存穿透：一个无效ID查询的时候先查Redis如果没有，就会去数据库查询 反复循环</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>解决方案：查询数据库的数据的时候，不管查询到的数据有没有
都通过Redis缓存起来，并设置一个过期时间
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2 缓存雪崩：同一时间 有大量的数据访问 数据库 解决方案：在做缓存的时候通过 固定时间+随机时间 将数据进行缓存 保证数据不会在同一时间失效</p><p>3 缓存击穿：在缓存时间的时候，有大量的热点数据访问数据库，造成缓存击穿 解决方案： 1 最简单的方式就是将 热点数据设置永不超时</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2 对访问的key加互斥锁，如果请求的key不存在就加锁 去数据查拿数据
新的数据过来如果key相等则等 10 s再去缓存拿数据
如果key不同，则直接去缓存拿数据
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-redis-如何实现高并发、高可用" tabindex="-1"><a class="header-anchor" href="#_5-redis-如何实现高并发、高可用" aria-hidden="true">#</a> 5 redis 如何实现高并发、高可用</h2><h3 id="高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" tabindex="-1"><a class="header-anchor" href="#高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" aria-hidden="true">#</a> 高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发</h3><h3 id="高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" tabindex="-1"><a class="header-anchor" href="#高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" aria-hidden="true">#</a> 高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点</h3><p>Redis的哨兵模式：通过Sentinel 会不断的监控主服务和从服务 是否正常进行 当检测到某个redis服务出现故障，sentinel会通过Api的方式通知管理员 当redis的主节点失效是 sentinel会自动的讲 从节点随机抽取一个 提升为主节点，并且将 其他的从节点指向新的 主节点</p><h2 id="_6-redis-的性能优化-和解决方案" tabindex="-1"><a class="header-anchor" href="#_6-redis-的性能优化-和解决方案" aria-hidden="true">#</a> 6 redis 的性能优化，和解决方案</h2><p>( 1 )Master最好不要做任何持久化工作，如 RDB内存快照和 AOF日志文件 ( 2 ) 如果数据比较重要，某个 Slave 开启 AOF备份数据，策略设置为每秒同步一次 ( 3 ) 为了主从复制的速度和连接的稳定性， Master和 Slave最好在同一个局域网内 ( 4 ) 尽量避免在压力很大的主库上增加从库 ( 5 ) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master&lt;-Slave 1 &lt;-Slave 2 &lt;- Slave 3 ...</p><h2 id="_7-redis-的-trdlock-红锁的实现" tabindex="-1"><a class="header-anchor" href="#_7-redis-的-trdlock-红锁的实现" aria-hidden="true">#</a> 7 redis 的 TrdLock 红锁的实现</h2><p>1 在获取锁的时候使用 setnx如果返回 0 就是有人在使用 1 就可以获取锁 设置获取锁的超时时间，如果在时间内没获取到 就放弃加锁</p><p>2 释放锁的时候通过UUID 来判断是不是该锁，如果是在通过delete 释放锁</p><h2 id="_8-redis-的过期策略" tabindex="-1"><a class="header-anchor" href="#_8-redis-的过期策略" aria-hidden="true">#</a> 8 redis 的过期策略</h2><p>Key的时间到了不会立即删除 1 定期删除：redis会定期的去查看过期的key会随机删除 3 个 2 惰性删除：如果去查询一个过期的key时，redis会先查看key是否过期 如果过期会立即删除，并且返回空</p><h2 id="三-mybatis" tabindex="-1"><a class="header-anchor" href="#三-mybatis" aria-hidden="true">#</a> 三 Mybatis</h2><h2 id="_1-mybatis-的优缺点" tabindex="-1"><a class="header-anchor" href="#_1-mybatis-的优缺点" aria-hidden="true">#</a> 1 mybatis 的优缺点</h2><h3 id="优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" tabindex="-1"><a class="header-anchor" href="#优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" aria-hidden="true">#</a> 优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性</h3><p>缺点：sql编写工作量打，数据库移植性差</p><h2 id="_2-mybatis-的-1-2-级缓存" tabindex="-1"><a class="header-anchor" href="#_2-mybatis-的-1-2-级缓存" aria-hidden="true">#</a> 2 mybatis 的 1 ， 2 级缓存</h2><p>1 1 级缓存：默认开启的结构Map 第一次进行sql查询的时候会默认的将查询的结果放入sqlsession缓存中，每次查询的 时候先从缓存中取数据，如果缓存中没有的话再去数据库查询，查出来再放入sqlsession中 （如果sql查询语句不同的话，对应的缓存对象也不同）</p><p>2 2 级缓存：手动开启 全局缓存 结构Map 二级缓存是mapper级别的缓存 一个会话首先会放入一级缓存中，如果该会话关闭，就会把一级缓存的数据放入二级缓存中 新的会话就会参照 二级缓存。</p><p>开启会话缓存---》需要再每个Mapper.xml中手动配置</p><p>三级缓存 ，搭配 redis的缓存</p><h1 id="_3-spring-全家桶" tabindex="-1"><a class="header-anchor" href="#_3-spring-全家桶" aria-hidden="true">#</a> 3 Spring 全家桶</h1><h2 id="一-spring" tabindex="-1"><a class="header-anchor" href="#一-spring" aria-hidden="true">#</a> 一 Spring</h2><h2 id="_1-为什么使用-spring" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用-spring" aria-hidden="true">#</a> 1 为什么使用 spring</h2><p>1 方便解藕，可以讲对象间的依赖关系交给spring管理 2 spring支持Apo切面编程，可以很方便的对程序进行监控和拦截 3 ioc，控制反转 4 方便测试，可以联合junit进行单元测试 5 集成其他框架比较方便</p><h2 id="_2-什么是-aop-ioc" tabindex="-1"><a class="header-anchor" href="#_2-什么是-aop-ioc" aria-hidden="true">#</a> 2 什么是 Aop ， Ioc</h2><p>1 Aop切面编程，在原有的基础上通过Aop添加新的功能，而原有的功能并不知道新添加 的功能 简单来说就是：在某个方法/类，执行前打个标记声明干什么，之后执行什么，插入的新的 方法</p><p>2 Ioc 控制反转，负责创建对象，管理对象，（依赖注入的方式） 将创建的对象和对象之间的维护交有Spring管理</p><p>传统：自己new一个对象或者get一个直接/简介获取一个对象（耦合度高） Spring：spring容器使用工厂模式建造对象，不用自己创建，直接调用即可</p><h2 id="_3-spring-的注入方式" tabindex="-1"><a class="header-anchor" href="#_3-spring-的注入方式" aria-hidden="true">#</a> 3 spring 的注入方式</h2><p>1 构造注入：一般都话通过构造注入的方式，@Autowired/@Rsource进行注入 2 setter方式注入：Bean注入</p><h2 id="_4-springbean-的声命周期" tabindex="-1"><a class="header-anchor" href="#_4-springbean-的声命周期" aria-hidden="true">#</a> 4 springBean 的声命周期</h2><p>首先Bean可以通过注解 @BeanFactory创建Bean @ConfigRe 将Bean交由Spring的ioc进行管理</p><p>Bean是单厉模式--每次请求都会创建新的Bean---每次每次request---每次session会话</p><p>实例化-------------属性赋值------------初始化-----------销毁 （容器关闭时销毁） @PostConstruct （初始化init） @PreDestroy（销毁destroy）</p><p>继承Bean的方法BeanNameAware/beanFactroyAware/ApplicationContextAware/ setBeanName/setBeanFactroy/setApplicationContext</p><h2 id="_5-spring-的自动装配" tabindex="-1"><a class="header-anchor" href="#_5-spring-的自动装配" aria-hidden="true">#</a> 5 spring 的自动装配</h2><h3 id="容器不会自动装配" tabindex="-1"><a class="header-anchor" href="#容器不会自动装配" aria-hidden="true">#</a> 容器不会自动装配</h3><p>Spring可以通过BeanFactory中注入的方式来搞定Bean之间的依赖关系，达到自动装配 （尽量少用，如果非要使用可以用ByName来解决）</p><p>byName可以根据bean的名称注入 匹配并装配xml文件中由相同名称定义的Bean</p><h2 id="_6-spring-框架用到了那些设计模式" tabindex="-1"><a class="header-anchor" href="#_6-spring-框架用到了那些设计模式" aria-hidden="true">#</a> 6 spring 框架用到了那些设计模式</h2><p>代理模式：在Aop中使用最多 单例模式：Bean默认是单例模式 工厂模式：BeanFactory 依赖注入模式：BeanFactory/ApplicationContext 试图：Spring的一系列jsp标签</p><h2 id="_7-spring-的事务性" tabindex="-1"><a class="header-anchor" href="#_7-spring-的事务性" aria-hidden="true">#</a> 7 spring 的事务性</h2><h3 id="可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" tabindex="-1"><a class="header-anchor" href="#可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" aria-hidden="true">#</a> 可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现</h3><p>@Transactional通过该注解的 rollbackFor/noRollbackFor来实现异常回滚（public修饰） Propagation 事务传播 （ 7 种） Isolation 事务的隔离级别 （已提交、未提交、可重复读） ReadOnly读写默认true读写手动false只读 Timeout 超时时间 原子性：要么全部成功，要么全部失败 一致性：从事务开始-到事务结束，数据库的完整性没有被破坏 隔离性：在多个事务并行进行 读写、修改等操作是不会交叉而导致数据不一致， 持久性：事务结束后，对数据的修改是永久性的，不会因为系统故障而造成数据丢失。</p><h2 id="二-springmvc" tabindex="-1"><a class="header-anchor" href="#二-springmvc" aria-hidden="true">#</a> 二 SpringMVC</h2><h2 id="_1-什么是-springmvc" tabindex="-1"><a class="header-anchor" href="#_1-什么是-springmvc" aria-hidden="true">#</a> 1 什么是 springMvc</h2><p>M：Model 模型 负责业务通信处理数据 service、dao V：View 试图 渲染数据jsp、html等 C：Controller控制层 对接请求，控制MVC的流程 调度模型、选择试图、接受请求、响 应数据、service等</p><p>工作流程： Controller接受请求，调用model处理请求，处理完返回controller，再响应View渲染</p><h2 id="_2-mvc-有那些组件" tabindex="-1"><a class="header-anchor" href="#_2-mvc-有那些组件" aria-hidden="true">#</a> 2 MVC 有那些组件</h2><p>1 .DispatcherServlet 前端控制器 2 .HandlerMapping请求派发,建立请求和处理器的映射 3 .Controller处理器 4 .ModelAndView封装模型和试图信息 4 .ViewResolver视图处理器,定位页面</p><h2 id="三-springboot" tabindex="-1"><a class="header-anchor" href="#三-springboot" aria-hidden="true">#</a> 三 SpringBoot</h2><h2 id="_1-什么是-springboot-你对-springboot-的理解" tabindex="-1"><a class="header-anchor" href="#_1-什么是-springboot-你对-springboot-的理解" aria-hidden="true">#</a> 1 什么是 springBoot/ 你对 springBoot 的理解</h2><h3 id="_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" tabindex="-1"><a class="header-anchor" href="#_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" aria-hidden="true">#</a> 1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架</h3><p>开发速度快，测试简单，配置简单，部署简单（自带Tomcat），建华maven的配置</p><h2 id="_2-springboot-的配置" tabindex="-1"><a class="header-anchor" href="#_2-springboot-的配置" aria-hidden="true">#</a> 2 springBoot 的配置</h2><p>Application、bootstrap 1 application主要是用于springBoot项目的配置 2 bootstrap 主要是用于springCloud的配置</p><p>有properties 和yml 两种配置类型（区别是格式不同）</p><h2 id="_3-springbootapplication-的作用" tabindex="-1"><a class="header-anchor" href="#_3-springbootapplication-的作用" aria-hidden="true">#</a> 3 SpringBootApplication 的作用</h2><h3 id="放在启动了上、、、此注解中包含三个注解" tabindex="-1"><a class="header-anchor" href="#放在启动了上、、、此注解中包含三个注解" aria-hidden="true">#</a> 放在启动了上、、、此注解中包含三个注解</h3><p>@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration</p><p>1 @SpringBootConfiguration 中只有一个注解@Configuration 表示这是一个配置类 2 @ComponentScan自动扫描包，（交由ioc容器管理） Controller、service底层都是有@Component注解 将这些都自动装配到容器中 Dao、Mapper层需要手动开启@MapperScan指定 3 @EnableAutoConfiguration 讲所有@Configuration加载到 加载到spring容器中</p><h2 id="四-spring-、-springmvc-、-springboot-区别" tabindex="-1"><a class="header-anchor" href="#四-spring-、-springmvc-、-springboot-区别" aria-hidden="true">#</a> 四 spring 、 springMVC 、 springBoot 区别</h2><p>Spring： MVC：前后端交互 SringBoot：整合所有框架</p><h1 id="_4-mysql" tabindex="-1"><a class="header-anchor" href="#_4-mysql" aria-hidden="true">#</a> 4 Mysql</h1><h2 id="一-sql-基础" tabindex="-1"><a class="header-anchor" href="#一-sql-基础" aria-hidden="true">#</a> 一 sql 基础</h2><h2 id="_1-mysql-四大操作" tabindex="-1"><a class="header-anchor" href="#_1-mysql-四大操作" aria-hidden="true">#</a> 1 mysql 四大操作</h2><h3 id="crud" tabindex="-1"><a class="header-anchor" href="#crud" aria-hidden="true">#</a> CRUD</h3><p>1 select 查询 select*fromtable 2 delete删除 deletetable(注意加上where条件 不然删除的是整个表) 3 update修改updatesettablea=bwhere？ 4 insert新增 insertintotable（） value （）</p><h2 id="_2-mysql-常用类型" tabindex="-1"><a class="header-anchor" href="#_2-mysql-常用类型" aria-hidden="true">#</a> 2 mysql 常用类型</h2><p>int、double、declmal（ 0 ， 0 ）、char、varchar、text、blob、date、time、year、dateTime</p><h2 id="_3-mysql-常用关键字" tabindex="-1"><a class="header-anchor" href="#_3-mysql-常用关键字" aria-hidden="true">#</a> 3 mysql 常用关键字</h2><p>Select、from、join、on、where、distinct、where、having、groupby、orderby、limit And、or、like、isnull、isnotnull、between（范围）、top、AS、into（复制）、explain、in 顺序： from-&gt;on-&gt;join-&gt;where-&gt;groupby-&gt;聚合函数 -&gt;having-&gt;select-&gt;distinct-&gt;orderby-&gt; limit Leftjoin （左关联）、rightjoin（右关联）、innerjoin（内关联）所有匹配的都显示</p><h2 id="_4-mysql-常用函数" tabindex="-1"><a class="header-anchor" href="#_4-mysql-常用函数" aria-hidden="true">#</a> 4 mysql 常用函数</h2><h3 id="聚合函数、日期函数、字符串函数、数值函数、流程控制函数" tabindex="-1"><a class="header-anchor" href="#聚合函数、日期函数、字符串函数、数值函数、流程控制函数" aria-hidden="true">#</a> 聚合函数、日期函数、字符串函数、数值函数、流程控制函数</h3><h3 id="_1-聚合函数" tabindex="-1"><a class="header-anchor" href="#_1-聚合函数" aria-hidden="true">#</a> 1 聚合函数</h3><p>Max（最大值）、min（最小值）、count（统计）、sum（求和）、avg（求平均值）</p><h3 id="_2-时间函数" tabindex="-1"><a class="header-anchor" href="#_2-时间函数" aria-hidden="true">#</a> 2 时间函数</h3><p>curDate（当前日期）、curTime（当前时间）、new/sysDate（当前时间）、month（当前月）、 dayName（星期几）、weer（第几周）、dayOfYear（周第几天）、dayOfMonth（月第几天）、 Year（年分）、time_to_sec（时间转秒）、date_add/addDate（添加间隔）、 date_sub/subDate（减去间隔）、addTime（+时间）、subTime（-时间）、date_format（格 式化）</p><p>3 字符串函数： Length（长度）、concat（合并）、insert（替换）、lower（转大写）、upper（转大写）、 Left（左截取）、right（右截取）、trim（删除左右空格）、replace（替换，反新）、 Substring（截取）、reverse（反转）</p><p>4 数值函数： Abs（绝对值）、sqrt（二次方跟）、mod（求余）、ceil（返回大于目标值，上）、floor（下）、 Round（四舍五入）、sign（返回符号）、pow（两个值的次方结果）、sin（正弦）、asin（反）、 Cos（余弦）、acos（反）、tan（正切）、atan（反）、cot（余切）</p><p>5 流控制函数、 If（判断，流程控制）、ifnull（是否为空）、case（搜索语句）</p><h2 id="二-sql-事务" tabindex="-1"><a class="header-anchor" href="#二-sql-事务" aria-hidden="true">#</a> 二 sql 事务</h2><h2 id="_1-数据库的三大范氏" tabindex="-1"><a class="header-anchor" href="#_1-数据库的三大范氏" aria-hidden="true">#</a> 1 数据库的三大范氏</h2><h3 id="第一范氏-数据库的每一列都是不可分割的原子数据" tabindex="-1"><a class="header-anchor" href="#第一范氏-数据库的每一列都是不可分割的原子数据" aria-hidden="true">#</a> 第一范氏：数据库的每一列都是不可分割的原子数据</h3><h3 id="例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" tabindex="-1"><a class="header-anchor" href="#例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" aria-hidden="true">#</a> 例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用</h3><h3 id="第二范氏-实体的属性不能完全依赖于主关键字" tabindex="-1"><a class="header-anchor" href="#第二范氏-实体的属性不能完全依赖于主关键字" aria-hidden="true">#</a> 第二范氏：实体的属性不能完全依赖于主关键字</h3><h3 id="第三范氏-任何非主属性不依赖于其他主属性" tabindex="-1"><a class="header-anchor" href="#第三范氏-任何非主属性不依赖于其他主属性" aria-hidden="true">#</a> 第三范氏：任何非主属性不依赖于其他主属性</h3><h3 id="第四范氏-一张表中-尽量不要使用多对多的关系" tabindex="-1"><a class="header-anchor" href="#第四范氏-一张表中-尽量不要使用多对多的关系" aria-hidden="true">#</a> 第四范氏：一张表中，尽量不要使用多对多的关系</h3><h3 id="第五范氏-从最终结构重新建立原始结构" tabindex="-1"><a class="header-anchor" href="#第五范氏-从最终结构重新建立原始结构" aria-hidden="true">#</a> 第五范氏：从最终结构重新建立原始结构</h3><h2 id="_2-事务的四大特性" tabindex="-1"><a class="header-anchor" href="#_2-事务的四大特性" aria-hidden="true">#</a> 2 事务的四大特性</h2><h3 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h3><p>原子性（Atomicity）：事务要么全部成功，要么全部失败。 一致性（Consistency）：事务开始到结束，数据库的完整性没有被破坏。 隔离性（Isolation）：多个用户同时操作数据库时，对每个用户开启一个事务，多个事务同</p><h3 id="时开启的同时互不干扰-相互隔离" tabindex="-1"><a class="header-anchor" href="#时开启的同时互不干扰-相互隔离" aria-hidden="true">#</a> 时开启的同时互不干扰，相互隔离</h3><p>持久性（Durability）：事务一旦被提交，数据的改变就是永久性的，数据库故障也不会导致 数据的丢失。</p><h2 id="_3-事务的并发问题" tabindex="-1"><a class="header-anchor" href="#_3-事务的并发问题" aria-hidden="true">#</a> 3 事务的并发问题</h2><h3 id="_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" tabindex="-1"><a class="header-anchor" href="#_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" aria-hidden="true">#</a> 1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到</h3><h3 id="_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" tabindex="-1"><a class="header-anchor" href="#_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" aria-hidden="true">#</a> 2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致</h3><h3 id="_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" tabindex="-1"><a class="header-anchor" href="#_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" aria-hidden="true">#</a> 3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致</h3><h2 id="_4-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_4-事务的隔离级别" aria-hidden="true">#</a> 4 事务的隔离级别</h2><h3 id="_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" tabindex="-1"><a class="header-anchor" href="#_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" aria-hidden="true">#</a> 1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取</h3><h3 id="解决了事务更新丢失-但是会出现脏读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-但是会出现脏读" aria-hidden="true">#</a> 解决了事务更新丢失，但是会出现脏读</h3><h3 id="_2-读提交-第一个事务读取-其他数据可以进行读写操作" tabindex="-1"><a class="header-anchor" href="#_2-读提交-第一个事务读取-其他数据可以进行读写操作" aria-hidden="true">#</a> 2 读提交：第一个事务读取，其他数据可以进行读写操作</h3><h3 id="解决了事务更新丢失-脏读-但是可能出现不可重复读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-但是可能出现不可重复读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，但是可能出现不可重复读</h3><h3 id="_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" tabindex="-1"><a class="header-anchor" href="#_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" aria-hidden="true">#</a> 3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写</h3><h3 id="解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，不可重复读，但是会出现幻读</h3><h3 id="_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" tabindex="-1"><a class="header-anchor" href="#_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" aria-hidden="true">#</a> 4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行）</h3><h3 id="解决了事务更新丢失-脏读-不可重复的-幻读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-不可重复的-幻读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，不可重复的，幻读</h3><h3 id="事务排队执行-但是性能低-一般不会被使用" tabindex="-1"><a class="header-anchor" href="#事务排队执行-但是性能低-一般不会被使用" aria-hidden="true">#</a> 事务排队执行，但是性能低，一般不会被使用</h3><h2 id="三-sql-索引" tabindex="-1"><a class="header-anchor" href="#三-sql-索引" aria-hidden="true">#</a> 三 sql 索引</h2><h2 id="_1-什么是索引" tabindex="-1"><a class="header-anchor" href="#_1-什么是索引" aria-hidden="true">#</a> 1 什么是索引</h2><h3 id="索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" tabindex="-1"><a class="header-anchor" href="#索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" aria-hidden="true">#</a> 索引是数据库的一个排序的数据结构，索引使用B树，B+树实现</h3><h2 id="_2-索引的作用" tabindex="-1"><a class="header-anchor" href="#_2-索引的作用" aria-hidden="true">#</a> 2 索引的作用</h2><h3 id="快速查找-更新表中数据" tabindex="-1"><a class="header-anchor" href="#快速查找-更新表中数据" aria-hidden="true">#</a> 快速查找，更新表中数据</h3><h3 id="代价-数据库存储空间增加-插入和修改花费时间较多" tabindex="-1"><a class="header-anchor" href="#代价-数据库存储空间增加-插入和修改花费时间较多" aria-hidden="true">#</a> 代价：数据库存储空间增加，插入和修改花费时间较多</h3><h2 id="_3-索引的分类" tabindex="-1"><a class="header-anchor" href="#_3-索引的分类" aria-hidden="true">#</a> 3 索引的分类</h2><h3 id="_1-普通索引-仅加速查询" tabindex="-1"><a class="header-anchor" href="#_1-普通索引-仅加速查询" aria-hidden="true">#</a> 1 普通索引：仅加速查询</h3><p>2 唯一索引：加速查询 +列值唯一（可以为null）。 3 主键索引：加速查询 +列值唯一（不可以为null）+ 表中只有一个。 4 组合索引：多列值组成一个索引，专门用于组合搜索。 5 全文索引：对文本内容进行分词，进行搜索。</p><p>索引的最佳左匹配原则： 在检索数据是会从最左边开始匹配 唯一、不为空、经常被查询的字段、作为查询条件的字段，都可以建立索引。</p><h2 id="_4-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_4-索引的优缺点" aria-hidden="true">#</a> 4 索引的优缺点</h2><h3 id="优点-可以大大的提升性能" tabindex="-1"><a class="header-anchor" href="#优点-可以大大的提升性能" aria-hidden="true">#</a> 优点：可以大大的提升性能</h3><h3 id="_1-唯一索引-可以保证每一行数据的唯一性" tabindex="-1"><a class="header-anchor" href="#_1-唯一索引-可以保证每一行数据的唯一性" aria-hidden="true">#</a> 1 唯一索引：可以保证每一行数据的唯一性</h3><h3 id="_2-提升了数据的检索速度" tabindex="-1"><a class="header-anchor" href="#_2-提升了数据的检索速度" aria-hidden="true">#</a> 2 提升了数据的检索速度</h3><h3 id="_3-可以加速表与表之间的连接" tabindex="-1"><a class="header-anchor" href="#_3-可以加速表与表之间的连接" aria-hidden="true">#</a> 3 可以加速表与表之间的连接</h3><h3 id="_4-查询速度快" tabindex="-1"><a class="header-anchor" href="#_4-查询速度快" aria-hidden="true">#</a> 4 查询速度快</h3><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><h3 id="_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" tabindex="-1"><a class="header-anchor" href="#_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" aria-hidden="true">#</a> 1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度</h3><h3 id="_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" tabindex="-1"><a class="header-anchor" href="#_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" aria-hidden="true">#</a> 2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大）</h3><h3 id="_3-维护索引时间增加" tabindex="-1"><a class="header-anchor" href="#_3-维护索引时间增加" aria-hidden="true">#</a> 3 维护索引时间增加</h3><h2 id="_5-b-树和-b-树" tabindex="-1"><a class="header-anchor" href="#_5-b-树和-b-树" aria-hidden="true">#</a> 5 B 树和 B+ 树</h2><p>Hash索引和B+树索引的区别： Hash索引查询效率高，不能排序，不能查找。B+树索引，可以范围查找、可以排序。</p><p>1 树的每个节点都存储在key和Data，组成的树，读写代价低， 并且叶子节点的指针为null，叶子节点不包含任何关键字的信息。</p><p>2 B+树的叶子节点包含了全部都关键字信息，并且指向来含有这些关键字的指针， 且叶子节点本身根据关键字从小到大的顺序链接，查询效率稳定。</p><p>因为B+树，叶子节点的关键字存储 的路径长度相同，所以查询效率相同。</p><h2 id="四-mysql-的存储引擎" tabindex="-1"><a class="header-anchor" href="#四-mysql-的存储引擎" aria-hidden="true">#</a> 四 mysql 的存储引擎</h2><h2 id="_1-mysql-的存储引擎有那些" tabindex="-1"><a class="header-anchor" href="#_1-mysql-的存储引擎有那些" aria-hidden="true">#</a> 1 mysql 的存储引擎有那些</h2><p>最常用的有innoDB，myISAM，memory 1 事务安全：innoDB支持事务安全，myISAM和memory不支持。 2 存储限制：innoDB有 64 TB的存储限制，myISAM和memory不固定。 3 空间使用：innoDB对空间使用程度较高，myISAM和memory对空间使用较低。 4 内存使用：innoDB和memory对内存使用较高，myISAM对内存使用较低。 5 插入速度：innoDB插入速度较低，myISAM和memory插入速度较高。 6 外键支持：innoDB对外键支持情况好，myISAM和memory不支持外键。</p><h2 id="_2-mysql-的存储过程" tabindex="-1"><a class="header-anchor" href="#_2-mysql-的存储过程" aria-hidden="true">#</a> 2 mysql 的存储过程</h2><h3 id="存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" tabindex="-1"><a class="header-anchor" href="#存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" aria-hidden="true">#</a> 存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用</h3><h3 id="_1-可以使用一个命令对象调用存储过程" tabindex="-1"><a class="header-anchor" href="#_1-可以使用一个命令对象调用存储过程" aria-hidden="true">#</a> 1 可以使用一个命令对象调用存储过程</h3><p>2 可以使用外部程序调用，列：java程序。</p><h2 id="_3-存储过程的优缺点" tabindex="-1"><a class="header-anchor" href="#_3-存储过程的优缺点" aria-hidden="true">#</a> 3 存储过程的优缺点</h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><h3 id="_1-存储过程是预编译过的-执行效率高" tabindex="-1"><a class="header-anchor" href="#_1-存储过程是预编译过的-执行效率高" aria-hidden="true">#</a> 1 存储过程是预编译过的，执行效率高</h3><h3 id="_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" tabindex="-1"><a class="header-anchor" href="#_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" aria-hidden="true">#</a> 2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信）</h3><h3 id="_3-安全性高-需要有一定权限的用户执行" tabindex="-1"><a class="header-anchor" href="#_3-安全性高-需要有一定权限的用户执行" aria-hidden="true">#</a> 3 安全性高，需要有一定权限的用户执行</h3><h3 id="_4-可以重复使用-减少代码量" tabindex="-1"><a class="header-anchor" href="#_4-可以重复使用-减少代码量" aria-hidden="true">#</a> 4 可以重复使用，减少代码量</h3><h3 id="缺点-移植性差" tabindex="-1"><a class="header-anchor" href="#缺点-移植性差" aria-hidden="true">#</a> 缺点：移植性差</h3><h2 id="五-sql-优化" tabindex="-1"><a class="header-anchor" href="#五-sql-优化" aria-hidden="true">#</a> 五 sql 优化</h2><h2 id="_1-怎么查找需要优化的数据" tabindex="-1"><a class="header-anchor" href="#_1-怎么查找需要优化的数据" aria-hidden="true">#</a> 1 怎么查找需要优化的数据</h2><h3 id="定位——分析——解决" tabindex="-1"><a class="header-anchor" href="#定位——分析——解决" aria-hidden="true">#</a> 定位——分析——解决</h3><p>1 定位：首先先查找定位需要优化的sql语句（debug、日志（show.log）） 1 可以通过mysql的慢查询 查询执行慢的语句show.log 2 可以通过Druid数据源，sql监控，获取执行慢的语句 3 采用第三方软件 innotop 4 SpringAop环绕通知</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>5 阿里云，腾讯云的sql检测报告，优化建议
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2 分析：分析sql执行慢的原因。解决：解决问题优化 1 并发量（缓存，数据库扩容（mycat））。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2 数据量（分页，数据库分片（按月））。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>3 最短路径（关系型数据库，尽量以最短的线路，拿出数据）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>4 索引（避免索引牵扯运算、最佳左匹配原则、索引是否生效（explain）、索引数量）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>5 计算（避免索引参与运算、尽量把运算放入代码中）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>6 冗余（尽量避免有冗余的条件在sql中执行、简化sql）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>7 条件顺序（能放on中过滤的尽量不要放入where中，最后是having）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_5-jvm" tabindex="-1"><a class="header-anchor" href="#_5-jvm" aria-hidden="true">#</a> 5 JVM</h1><h2 id="一内存" tabindex="-1"><a class="header-anchor" href="#一内存" aria-hidden="true">#</a> 一内存</h2><h2 id="_1-类加载的过程" tabindex="-1"><a class="header-anchor" href="#_1-类加载的过程" aria-hidden="true">#</a> 1 类加载的过程</h2><h3 id="加载——校验——准备——解析——初始化——使用——卸载" tabindex="-1"><a class="header-anchor" href="#加载——校验——准备——解析——初始化——使用——卸载" aria-hidden="true">#</a> 加载——校验——准备——解析——初始化——使用——卸载</h3><p>1 加载：讲Class的二进制内容加载到方法区（jar、war）。 2 校验：验证Class的二进制文件是否合格（字节码验证、符号验证）。 3 准备：虚拟机在方法区为class分配内存、初始化静态变量的默认值。 4 解析：验证成员变量、方法、静态变量，是否能正常解析。 5 初始化：在内存中构造一个class对象，来表示该类。</p><h2 id="_2-java-中类的声明周期" tabindex="-1"><a class="header-anchor" href="#_2-java-中类的声明周期" aria-hidden="true">#</a> 2 java 中类的声明周期</h2><h3 id="加载——连接——初始化——使用——卸载" tabindex="-1"><a class="header-anchor" href="#加载——连接——初始化——使用——卸载" aria-hidden="true">#</a> 加载——连接——初始化——使用——卸载</h3><p>1 加载：查找加载类的二进制数据，并在堆中创建一个class对象。 2 连接：验证（文件格式、元数据、字节码等），准备（初始化静态变量的默认值）。 3 初始化：为类的静态变量赋予正确的初始值。 4 使用：new出对象在程序中使用 5 卸载：执行垃圾回收</p><h2 id="_3-什么是双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_3-什么是双亲委派模型" aria-hidden="true">#</a> 3 什么是双亲委派模型</h2><h3 id="双亲委派模型是一个类的加载过程" tabindex="-1"><a class="header-anchor" href="#双亲委派模型是一个类的加载过程" aria-hidden="true">#</a> 双亲委派模型是一个类的加载过程</h3><h3 id="一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" tabindex="-1"><a class="header-anchor" href="#一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" aria-hidden="true">#</a> 一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父</h3><h3 id="加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" tabindex="-1"><a class="header-anchor" href="#加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" aria-hidden="true">#</a> 加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载</h3><h3 id="优点-防止内存中出现多份同样的字节码" tabindex="-1"><a class="header-anchor" href="#优点-防止内存中出现多份同样的字节码" aria-hidden="true">#</a> 优点：防止内存中出现多份同样的字节码</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>打破：继承ClassLoader类，重写loadClass和findClass方法
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-堆和栈道区别" tabindex="-1"><a class="header-anchor" href="#_4-堆和栈道区别" aria-hidden="true">#</a> 4 堆和栈道区别</h2><h3 id="栈-内存用来存储局部变量和方法的调用" tabindex="-1"><a class="header-anchor" href="#栈-内存用来存储局部变量和方法的调用" aria-hidden="true">#</a> 栈：内存用来存储局部变量和方法的调用</h3><p>堆：内存用来存储java的对象，不论成员变量、局部变量、类变量、都是在堆的内存中。</p><p>栈：线程私有 堆：线程共享</p><p>栈的内存小于堆的内存</p><h2 id="二-cg-算法" tabindex="-1"><a class="header-anchor" href="#二-cg-算法" aria-hidden="true">#</a> 二 CG 算法</h2><h2 id="_1-jvm-有那些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_1-jvm-有那些垃圾回收算法" aria-hidden="true">#</a> 1 JVM 有那些垃圾回收算法</h2><h3 id="标记-清除算法——标记-整理算法——复制算法——分代算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法——标记-整理算法——复制算法——分代算法" aria-hidden="true">#</a> 标记-清除算法——标记-整理算法——复制算法——分代算法</h3><h3 id="_1-标记-清除算法-标记无用的对象-然后进行清除回收" tabindex="-1"><a class="header-anchor" href="#_1-标记-清除算法-标记无用的对象-然后进行清除回收" aria-hidden="true">#</a> 1 标记-清除算法：标记无用的对象，然后进行清除回收</h3><h3 id="缺点-效率不高-无法清除垃圾碎片" tabindex="-1"><a class="header-anchor" href="#缺点-效率不高-无法清除垃圾碎片" aria-hidden="true">#</a> 缺点：效率不高，无法清除垃圾碎片</h3><h3 id="_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" tabindex="-1"><a class="header-anchor" href="#_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" aria-hidden="true">#</a> 2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存</h3><h3 id="_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" tabindex="-1"><a class="header-anchor" href="#_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" aria-hidden="true">#</a> 3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后</h3><h3 id="将或者的对象复制到另一个区域中-再清除用完的区域" tabindex="-1"><a class="header-anchor" href="#将或者的对象复制到另一个区域中-再清除用完的区域" aria-hidden="true">#</a> 将或者的对象复制到另一个区域中，再清除用完的区域</h3><h3 id="缺点-内存使用率低-只有原来的一般空间" tabindex="-1"><a class="header-anchor" href="#缺点-内存使用率低-只有原来的一般空间" aria-hidden="true">#</a> 缺点：内存使用率低，只有原来的一般空间</h3><h3 id="_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" tabindex="-1"><a class="header-anchor" href="#_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" aria-hidden="true">#</a> 4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代</h3><h3 id="新生代一般采用复制算法-老年代一般采用标记整理算法" tabindex="-1"><a class="header-anchor" href="#新生代一般采用复制算法-老年代一般采用标记整理算法" aria-hidden="true">#</a> 新生代一般采用复制算法，老年代一般采用标记整理算法</h3><h2 id="_2-jvm-的垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-jvm-的垃圾回收器" aria-hidden="true">#</a> 2 JVM 的垃圾回收器</h2><h3 id="常用-cms、g-1" tabindex="-1"><a class="header-anchor" href="#常用-cms、g-1" aria-hidden="true">#</a> 常用：CMS、G 1</h3><p>另：serial、serialold、parNew、parallel、parallelold。</p><p>1 CMS：获得最短的时间为目标的收集器。非常适合B/S系统 2 G 1 ：兼容吞吐量和停顿时间的GC实现，JDK 9 以后默认是G 1</p><p>3 serial：最早的单线程回收器。 4 serialold：垃圾回收机的老版本，可以是CMS的备选方案。 5 parNew：是serial的多线程版本。 6 parallel：是parNew的收集器，类似于多线程，可以牺牲等待时间换取吞吐量。 7 parallelold：parallel是使用复制回收算法，parallelold是使用标记整理回收算法。</p><h2 id="_3-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_3-cms-垃圾回收器" aria-hidden="true">#</a> 3 CMS 垃圾回收器</h2><h3 id="cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" tabindex="-1"><a class="header-anchor" href="#cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" aria-hidden="true">#</a> CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片</h3><p>当剩余内存不能满足程序的运行需求时，CMS将临时采用serial的垃圾回收算法机制 此时性能会降低。</p><h2 id="_4-新生代和老年代的垃圾回收期有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_4-新生代和老年代的垃圾回收期有哪些-有什么区别" aria-hidden="true">#</a> 4 新生代和老年代的垃圾回收期有哪些，有什么区别</h2><p>新生代：serial、parNew、parallel、scavenge 老年代：serialold、parallelold、CMS 整堆回收算法：G 1</p><h2 id="_5-垃圾回收器是怎么工作的" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收器是怎么工作的" aria-hidden="true">#</a> 5 垃圾回收器是怎么工作的</h2><h3 id="分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" tabindex="-1"><a class="header-anchor" href="#分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" aria-hidden="true">#</a> 分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间）</h3><h3 id="_1-新生代-使用的是复制算法" tabindex="-1"><a class="header-anchor" href="#_1-新生代-使用的是复制算法" aria-hidden="true">#</a> 1 新生代：使用的是复制算法</h3><h3 id="_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" aria-hidden="true">#</a> 2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法</h3><h2 id="_6-java-中有那些引用类型" tabindex="-1"><a class="header-anchor" href="#_6-java-中有那些引用类型" aria-hidden="true">#</a> 6 java 中有那些引用类型</h2><h3 id="强引用——软引用——弱引用——虚引用" tabindex="-1"><a class="header-anchor" href="#强引用——软引用——弱引用——虚引用" aria-hidden="true">#</a> 强引用——软引用——弱引用——虚引用</h3><h3 id="_1-强引用-发生gc时不会被回收" tabindex="-1"><a class="header-anchor" href="#_1-强引用-发生gc时不会被回收" aria-hidden="true">#</a> 1 强引用：发生GC时不会被回收</h3><h3 id="_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" tabindex="-1"><a class="header-anchor" href="#_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" aria-hidden="true">#</a> 2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收</h3><h3 id="_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" tabindex="-1"><a class="header-anchor" href="#_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" aria-hidden="true">#</a> 3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收</h3><h3 id="_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" tabindex="-1"><a class="header-anchor" href="#_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" aria-hidden="true">#</a> 4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知</h3><h2 id="_7-gc-的触发条件" tabindex="-1"><a class="header-anchor" href="#_7-gc-的触发条件" aria-hidden="true">#</a> 7 GC 的触发条件</h2><h3 id="老年区空间不足、方法区空间不足、" tabindex="-1"><a class="header-anchor" href="#老年区空间不足、方法区空间不足、" aria-hidden="true">#</a> 老年区空间不足、方法区空间不足、</h3><h3 id="当复制算法等-进入老年代时平均大小大于老年代的空间时" tabindex="-1"><a class="header-anchor" href="#当复制算法等-进入老年代时平均大小大于老年代的空间时" aria-hidden="true">#</a> 当复制算法等，进入老年代时平均大小大于老年代的空间时</h3><h1 id="_6-多线程" tabindex="-1"><a class="header-anchor" href="#_6-多线程" aria-hidden="true">#</a> 6 多线程</h1><h2 id="一线程" tabindex="-1"><a class="header-anchor" href="#一线程" aria-hidden="true">#</a> 一线程</h2><h2 id="_1-进程和线程的区别" tabindex="-1"><a class="header-anchor" href="#_1-进程和线程的区别" aria-hidden="true">#</a> 1 进程和线程的区别</h2><h3 id="进程-应用程序执行的实例-有独立的内存空间和系统资源" tabindex="-1"><a class="header-anchor" href="#进程-应用程序执行的实例-有独立的内存空间和系统资源" aria-hidden="true">#</a> 进程：应用程序执行的实例，有独立的内存空间和系统资源</h3><h3 id="线程-cpu调度和分派的基本单位-应用程序是最小的单位" tabindex="-1"><a class="header-anchor" href="#线程-cpu调度和分派的基本单位-应用程序是最小的单位" aria-hidden="true">#</a> 线程：CPU调度和分派的基本单位，应用程序是最小的单位</h3><p>Main方法被称为主线程，一个程序至少有一个主线程</p><p>多线程：一个进程中运行了多个线程，称为多线程 好处：充分的利用cpu资源带来良好的体验</p><h2 id="_2-线程的状态" tabindex="-1"><a class="header-anchor" href="#_2-线程的状态" aria-hidden="true">#</a> 2 线程的状态</h2><h3 id="创建线程——就绪状态——运行状态——阻塞状态——死亡状态" tabindex="-1"><a class="header-anchor" href="#创建线程——就绪状态——运行状态——阻塞状态——死亡状态" aria-hidden="true">#</a> 创建线程——就绪状态——运行状态——阻塞状态——死亡状态</h3><p>1 创建线程：new线程对象。 2 就绪状态：调用start（）方法。 3 运行状态：抢占CPU资源，调用yield（）方法，进入就绪状态。 4 阻塞状态：join()/sleep(),如果阻塞结束，进入就绪状态。 5 死亡状态：线程执行完毕。</p><h2 id="_3-常用方法-调度" tabindex="-1"><a class="header-anchor" href="#_3-常用方法-调度" aria-hidden="true">#</a> 3 常用方法（调度）</h2><p>1 sleep（）：线程休眠。 2 join（）：线程插队。 3 yield（）：线程礼让。 4 run（）：线程启动。 5 start（）：启动所有线程（进入就绪状态，并不能立即执行）。</p><p>6 wait（）：线程等待。 7 notify（）：随机唤醒一个线程（JVM决定）。 8 notifyall（）：唤醒所有等待的线程，（并没有加锁，而是让它们抢占）。 9 volatile（）：修饰变量。</p><p>Run（）方法只是定义来一个线程的执行单元，并没有开启线程资源， 只有调用来start（）方法才可以启动线程，直接调用run（）不会创建线程。</p><p>Wait（）和notify（）必须配合synchronized{}关键字使用。 Wait（）释放锁，notify（）不释放锁。</p><p>可以使用volatile（）的布尔变量来退出正在运行的循环线程，或取消任务来中断线程。</p><h2 id="_4-线程的有点" tabindex="-1"><a class="header-anchor" href="#_4-线程的有点" aria-hidden="true">#</a> 4 线程的有点</h2><h3 id="_1-可重复使用存在的线程-减少对象创建销毁的开销" tabindex="-1"><a class="header-anchor" href="#_1-可重复使用存在的线程-减少对象创建销毁的开销" aria-hidden="true">#</a> 1 可重复使用存在的线程，减少对象创建销毁的开销</h3><h3 id="_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" tabindex="-1"><a class="header-anchor" href="#_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" aria-hidden="true">#</a> 2 提高系统资源的使用率，避免多资源竞争，避免阻塞</h3><h3 id="_3-提供定时-定期执行-单线程、并发等控制功能" tabindex="-1"><a class="header-anchor" href="#_3-提供定时-定期执行-单线程、并发等控制功能" aria-hidden="true">#</a> 3 提供定时，定期执行，单线程、并发等控制功能</h3><h2 id="_5-实现多线程的几种方法" tabindex="-1"><a class="header-anchor" href="#_5-实现多线程的几种方法" aria-hidden="true">#</a> 5 实现多线程的几种方法</h2><p>1 继承Thread类，重写run（）方法，用子类实例调用start（）方法。 2 实现Runnable接口，重写run（）方法。 3 创建Callable接口，重写call（）方法。</p><p>Runnable多个线程可以共享实例变量，callable不行。 Runnable方法没有返回值，callable有返回值。 Runnable的run（）方法只能在内部消化，callable的call（）方法可以抛出异常。</p><h2 id="_6-创建线程池的几种方法" tabindex="-1"><a class="header-anchor" href="#_6-创建线程池的几种方法" aria-hidden="true">#</a> 6 创建线程池的几种方法</h2><p>1 newSingleThreadExecutor（创建单线程线程池，可以保证任务顺序）</p><p>2 newFixedThreadPool（创建定长线程池，可控制线程最大并发数，超出等待）</p><p>3 newCachedThreadPool（创建可缓存线程池，有空闲的线程会回收，任务多，消耗资源）</p><p>4 newScheduledThradPool（创建一个大小无限的线程池，支持定时，周期任务需求）</p><h2 id="_7-线程池的状态" tabindex="-1"><a class="header-anchor" href="#_7-线程池的状态" aria-hidden="true">#</a> 7 线程池的状态</h2><p>1 running：一旦被创建，就处于此状态，可以接受新任务，和已经添加的任务处理。</p><p>2 shutdoww：不接受新任务，但是可以处理已添加的任务。</p><p>3 stop：停止（中断），不接受新任务，不处理已添加的任务，中断正在处理的任务</p><p>4 tidying：所有任务已终止的状态。</p><p>5 terminated：线程池彻底终止的状态。</p><h2 id="_8-线程池中-submit-和-execute-的区别" tabindex="-1"><a class="header-anchor" href="#_8-线程池中-submit-和-execute-的区别" aria-hidden="true">#</a> 8 线程池中 submit （）和 execute 的区别</h2><p>1 submit可以接受runnable类型的参数，execute可以接受runnable和callable类型的参数。 2 submit有返回值（Future），execute没有返回值。 3 submit可以很方便的处理Exception异常。</p><h2 id="_9-线程池的七大核心参数" tabindex="-1"><a class="header-anchor" href="#_9-线程池的七大核心参数" aria-hidden="true">#</a> 9 线程池的七大核心参数</h2><p>1 corePoolSize 核心线程数 2 maximumPoolSize 最大线程数，一般大于等于核心线程数 3 keepAliveTime线程存活时间(针对最大线程数大于核心线程数时，非核心线程) 4 unit 存活时间单位，和线程存活时间配套使用 5 workQueue 任务队列 6 threadFactory创建线程的工程 7 handler拒绝策略</p><h2 id="二线程安全" tabindex="-1"><a class="header-anchor" href="#二线程安全" aria-hidden="true">#</a> 二线程安全</h2><h2 id="_1-java-中怎么保证线程的安全" tabindex="-1"><a class="header-anchor" href="#_1-java-中怎么保证线程的安全" aria-hidden="true">#</a> 1 Java 中怎么保证线程的安全</h2><p>1 最简单的方式是使用synchronized关键字。 2 使用lock锁。 3 使用redisson中的RedLock（红锁）。</p><h2 id="_2-什么是死锁-怎么防止" tabindex="-1"><a class="header-anchor" href="#_2-什么是死锁-怎么防止" aria-hidden="true">#</a> 2 什么是死锁，怎么防止</h2><h3 id="死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" tabindex="-1"><a class="header-anchor" href="#死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" aria-hidden="true">#</a> 死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进</h3><h3 id="就会造成死锁" tabindex="-1"><a class="header-anchor" href="#就会造成死锁" aria-hidden="true">#</a> 就会造成死锁</h3><p>避免：确定顺序获取锁。（newSingleThreadExecutor单线程池） 超时放弃（lock锁就是使用了这种方式）</p><h2 id="_3-synchronized-的底层实现原理" tabindex="-1"><a class="header-anchor" href="#_3-synchronized-的底层实现原理" aria-hidden="true">#</a> 3 synchronized 的底层实现原理</h2><h3 id="每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" tabindex="-1"><a class="header-anchor" href="#每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" aria-hidden="true">#</a> 每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候</h3><h3 id="尝试获取锁的每个对象" tabindex="-1"><a class="header-anchor" href="#尝试获取锁的每个对象" aria-hidden="true">#</a> 尝试获取锁的每个对象</h3><p>1 如果每个监视器（monitor）的进入数为 0 时，则线程进入监视器（monitor）， 如果进入数为 1 时，则该线程为监视器（monitor）的拥有者。</p><p>2 如果线程已经占有监视器（monitor），只是重新进入，则进入数+ 1 。</p><p>3 如果其他线程已经占用监视器（monitor），则该线程会进入阻塞状态， 直接到监视器（monitor）的进入数为 0 时，再去尝试获取监视器的所有权限。</p><p>Synchronized是锁定当前变量，同一时刻只有一个线程能访问该变量。</p><h2 id="_4-synchronized-和-lock-的区别" tabindex="-1"><a class="header-anchor" href="#_4-synchronized-和-lock-的区别" aria-hidden="true">#</a> 4 synchronized 和 lock 的区别</h2><p>Synchronized是一个关键字，而Lock是一个借口 Synchronized无法判断锁的状态，而Lock锁可以判断锁的状态 Synchronized是自动释放锁，而Lock是需要手动释放锁。</p><p>Synchronized可重复，不可中断，非公平锁，而Lock可判断，可公平。 Synchronized获取锁的线程阻塞，其他线程都会自动等待，而Lock不会</p><h2 id="_5-锁的类别" tabindex="-1"><a class="header-anchor" href="#_5-锁的类别" aria-hidden="true">#</a> 5 锁的类别</h2><p>Synchronized：关键字（单机锁，一个一个获取，可能会造成死锁） Lock：接口（实现了synchronized的所有功能，但是需要手动释放锁） 方法：（voidlock获取锁，tryLock仅在未使用的情况下获取锁，isLock判断是否被占用） TryLock还可以设置获取锁的等待获取时间 公平锁、非公平锁： 公平锁：是指所有的线程按照排队顺序获取锁。</p><p>非公平锁：指多个线程获取锁的顺序，不是按照申请锁的顺序进行的。</p><p>ReentrantLock创建可以指定析构函数的Boolean类型，得到公平锁/非公平锁（默认非公平）</p><p>可重入锁、不可重入锁： 可重入：指的是可重复的使用锁，在外层用完后，内层还可以用，且不会造成死锁</p><p>不可重入：不可递归调用，递归调用就会产生死锁</p><p>乐观锁、悲观锁： 乐观锁：每次去拿数据的时候都认为别人不会修改，不会上锁， 但是在提交的时候还是会判断，在此期间有没有人去更新数据。</p><p>悲观锁：每次去那数据的时候都认为别人会修改数据，所以每次都会上锁， 有人拿读写数据就会阻止，直到这个锁释放，才会被其他人拿到。</p><h1 id="_7-数据类型" tabindex="-1"><a class="header-anchor" href="#_7-数据类型" aria-hidden="true">#</a> 7 数据类型</h1><h2 id="一容器" tabindex="-1"><a class="header-anchor" href="#一容器" aria-hidden="true">#</a> 一容器</h2><h2 id="_1-java-中有那些容器" tabindex="-1"><a class="header-anchor" href="#_1-java-中有那些容器" aria-hidden="true">#</a> 1 java 中有那些容器</h2><p>String（Array），以及Java.util下的集合类</p><p>1 List： ArrayList：有序，底层是一个空数组，第一次添加数据（ 10 ），扩容 1. 5 倍，查询、修改快。</p><p>LinkedList：双向链表实现，增加、删除快，不需要扩容，（先查询相邻的数据）。</p><p>Vector：初始化[ 10 ]的数据，扩容两倍。</p><p>线程安全：ArrayList（不安全）、LinkedLsit（不安全）、Vector（安全）。</p><p>2 map： HashMap：初始化 16 ，扩容 75 %/ 64 扩容两倍， 1. 7 数组+单项链表， 1. 8 数组+单项+红黑树。 不支持线程同步，无序。</p><p>TreeMap：实现SortMap接口，根据键排序，默认升序</p><p>LinkedHashMap：可以保证HashMap有序，</p><p>HashTable：线程安全（synchronized实现），不允许为bull，比hashMap多了elements方法。</p><p>3 set： Hashset：哈希表实现</p><p>TreeSet：树形结构实现，有序</p><p>4 Queue： 先进先出的原则，linkedList实现了Queue接口，不允许为NUll。 5 Stack： 后进先出的原则</p><h2 id="_2-5-大容器的特点、用法" tabindex="-1"><a class="header-anchor" href="#_2-5-大容器的特点、用法" aria-hidden="true">#</a> 2 5 大容器的特点、用法</h2><p>1 Lsit：有序可重复的集合，可以随意增加删除，使用迭代器遍历。</p><p>2 Map：键值对存储，key不允许重复为null，值可以重复为null。 HashMap不保证顺序，TreeMap可以保证顺序。 可以将key、value单独抽出，KeySet（）方法讲所有keys抽成set。 而Values（）方法可以将所有的values抽成一个集合。</p><p>3 Set：不可重复，没有同步方法，只允许一个为null，只能使用迭代器遍历。</p><p>4 Queue：先进先出原则，linkedList实现了Queue接口，不允许为NUll。</p><p>5 Stack：后进先出原则，测试堆栈是否为空empty（）方法。</p><p>用法： 1 涉及到堆栈，队列等操作：使用list。 2 涉及快速插入删除：LinkedList。 3 涉及快速访问修改：ArrayList。</p><h2 id="_3-那些容器是安全的-那些不安全" tabindex="-1"><a class="header-anchor" href="#_3-那些容器是安全的-那些不安全" aria-hidden="true">#</a> 3 那些容器是安全的，那些不安全</h2><p>安全：Vector、HashTable、Properties。 不安全：ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap。</p><h2 id="二-java-基础" tabindex="-1"><a class="header-anchor" href="#二-java-基础" aria-hidden="true">#</a> 二 java 基础</h2><h2 id="_1-sring-的常用方法" tabindex="-1"><a class="header-anchor" href="#_1-sring-的常用方法" aria-hidden="true">#</a> 1 Sring 的常用方法</h2><p>Equals（比较），format（格式化）、hashCode（哈西码）、isEmpty（）、join（指定拼接）、 Length（长度）、split（分割）、subString（截取）、trim（删除前后空格）、 valueOf（返回指定形式，int。。。）</p><h2 id="_2-final-关键字" tabindex="-1"><a class="header-anchor" href="#_2-final-关键字" aria-hidden="true">#</a> 2 final 关键字</h2><h3 id="修饰类-不能被继承" tabindex="-1"><a class="header-anchor" href="#修饰类-不能被继承" aria-hidden="true">#</a> 修饰类：不能被继承</h3><h3 id="修饰方法-不能被重写" tabindex="-1"><a class="header-anchor" href="#修饰方法-不能被重写" aria-hidden="true">#</a> 修饰方法：不能被重写</h3><h3 id="修饰变量-不能被修改" tabindex="-1"><a class="header-anchor" href="#修饰变量-不能被修改" aria-hidden="true">#</a> 修饰变量：不能被修改</h3><p>Final修饰的常量会放入常量池中。</p><h2 id="_3-方法重写和重载" tabindex="-1"><a class="header-anchor" href="#_3-方法重写和重载" aria-hidden="true">#</a> 3 方法重写和重载</h2><h3 id="重写-参数名、方法名、返回值必须保持一致" tabindex="-1"><a class="header-anchor" href="#重写-参数名、方法名、返回值必须保持一致" aria-hidden="true">#</a> 重写：参数名、方法名、返回值必须保持一致</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Final修饰的不能被重写，static修饰的不能被重写，构造方法不能被重写。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重载：方法名一致，顺序、个数、类型，只要有一个不同即可。 重载与返回值无关，可以抛出不同的异常，可以用不同的修饰符。</p><h2 id="_4-stringbuilder-、-stringbuffer-区别" tabindex="-1"><a class="header-anchor" href="#_4-stringbuilder-、-stringbuffer-区别" aria-hidden="true">#</a> 4 StringBuilder 、 StringBuffer 区别</h2><p>StringBuilder：线程安全 StringBuffer：线程不安全</p><p>大数据的批量拼接使用它两个 的append（）方法。</p><h2 id="_5-为什么重写-equals-必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_5-为什么重写-equals-必须重写-hashcode-方法" aria-hidden="true">#</a> 5 为什么重写 equals 必须重写 hashCode 方法</h2><p>两个值 equals相等hashCode相等，hashCoud相等equals不一定相等。</p><h2 id="_6-数组在内存中如何分配" tabindex="-1"><a class="header-anchor" href="#_6-数组在内存中如何分配" aria-hidden="true">#</a> 6 数组在内存中如何分配</h2><p>在new一个数组时，会在堆中分配空间，然后才返回引用，每个数组成员指向（引用）栈。</p><h2 id="_7-java-中的四大引用类型" tabindex="-1"><a class="header-anchor" href="#_7-java-中的四大引用类型" aria-hidden="true">#</a> 7 java 中的四大引用类型</h2><h3 id="强引用——软引用——弱引用——虚引用-1" tabindex="-1"><a class="header-anchor" href="#强引用——软引用——弱引用——虚引用-1" aria-hidden="true">#</a> 强引用——软引用——弱引用——虚引用</h3><p>强引用：不会被垃圾回收，String类型的，常量。</p><p>软引用：还有用但非必须对象，内存不足时会被回收。</p><p>弱引用：一旦被JVM发现，直接被回收。</p><p>虚引用：主要跟踪垃圾回收的活动。</p>`,419),n=[h];function s(t,c){return e(),r("div",null,n)}const o=a(d,[["render",s],["__file","interview10.html.vue"]]);export{o as default};
