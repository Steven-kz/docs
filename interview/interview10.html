<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.61">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logo.png"><title>无量心经 | StevenBlogs</title><meta name="description" content="Vue-powered Static Site Generator">
    <link rel="preload" href="/docs/assets/style-f4648f12.css" as="style"><link rel="stylesheet" href="/docs/assets/style-f4648f12.css">
    <link rel="modulepreload" href="/docs/assets/app-187343ba.js"><link rel="modulepreload" href="/docs/assets/framework-5866ffd3.js"><link rel="modulepreload" href="/docs/assets/interview10.html-3cc835ba.js"><link rel="modulepreload" href="/docs/assets/interview10.html-e1dfc020.js"><link rel="prefetch" href="/docs/assets/index.html-ed6c600e.js" as="script"><link rel="prefetch" href="/docs/assets/Beetl.html-c698048f.js" as="script"><link rel="prefetch" href="/docs/assets/ElasticSearch.html-b98e75e0.js" as="script"><link rel="prefetch" href="/docs/assets/Gateway.html-39302131.js" as="script"><link rel="prefetch" href="/docs/assets/Jmeter.html-85e652fd.js" as="script"><link rel="prefetch" href="/docs/assets/MinIO.html-498ac0b5.js" as="script"><link rel="prefetch" href="/docs/assets/RabbitMQ.html-4b727762.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-9cf86024.js" as="script"><link rel="prefetch" href="/docs/assets/Seckill.html-a7dff81a.js" as="script"><link rel="prefetch" href="/docs/assets/Sentinel.html-290e86e5.js" as="script"><link rel="prefetch" href="/docs/assets/Sleuth.html-674a3eba.js" as="script"><link rel="prefetch" href="/docs/assets/WebMagic.html-600d64ca.js" as="script"><link rel="prefetch" href="/docs/assets/AQS.html-f449ddb9.js" as="script"><link rel="prefetch" href="/docs/assets/Collection.html-0b1183f7.js" as="script"><link rel="prefetch" href="/docs/assets/ConcurrentHashMap.html-728d8204.js" as="script"><link rel="prefetch" href="/docs/assets/HashMap.html-2948b671.js" as="script"><link rel="prefetch" href="/docs/assets/interview1.html-635ff420.js" as="script"><link rel="prefetch" href="/docs/assets/interview2.html-f2f39d95.js" as="script"><link rel="prefetch" href="/docs/assets/interview3.html-b40befba.js" as="script"><link rel="prefetch" href="/docs/assets/interview4.html-17e3e0ab.js" as="script"><link rel="prefetch" href="/docs/assets/interview5.html-ccb26774.js" as="script"><link rel="prefetch" href="/docs/assets/interview6.html-0ebfb5f2.js" as="script"><link rel="prefetch" href="/docs/assets/interview7.html-d45afebe.js" as="script"><link rel="prefetch" href="/docs/assets/interview8.html-6cb8e24c.js" as="script"><link rel="prefetch" href="/docs/assets/interview9.html-bae8c391.js" as="script"><link rel="prefetch" href="/docs/assets/Java.html-725eb50a.js" as="script"><link rel="prefetch" href="/docs/assets/JVM.html-37be34a7.js" as="script"><link rel="prefetch" href="/docs/assets/MQ.html-67ba0661.js" as="script"><link rel="prefetch" href="/docs/assets/Mybatis.html-c8f183ec.js" as="script"><link rel="prefetch" href="/docs/assets/MySQL.html-2a4d6f9e.js" as="script"><link rel="prefetch" href="/docs/assets/MySQL18.html-44eea0b1.js" as="script"><link rel="prefetch" href="/docs/assets/Netty.html-9a3aa0a6.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-65780d9a.js" as="script"><link rel="prefetch" href="/docs/assets/Redis.html-f6a68cf4.js" as="script"><link rel="prefetch" href="/docs/assets/Spring.html-23322cbb.js" as="script"><link rel="prefetch" href="/docs/assets/Thread.html-3fc571f1.js" as="script"><link rel="prefetch" href="/docs/assets/Mysql进阶.html-e9f890d9.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-1fff67a1.js" as="script"><link rel="prefetch" href="/docs/assets/Docker.html-7867893c.js" as="script"><link rel="prefetch" href="/docs/assets/Docker安装Redis.html-4383bd36.js" as="script"><link rel="prefetch" href="/docs/assets/linux.html-4091b757.js" as="script"><link rel="prefetch" href="/docs/assets/Natapp内网穿透.html-4db34f0c.js" as="script"><link rel="prefetch" href="/docs/assets/PicGo.html-5a232101.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-0609a452.js" as="script"><link rel="prefetch" href="/docs/assets/Java实现参数校验的几种方式.html-b7462c81.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-996077dd.js" as="script"><link rel="prefetch" href="/docs/assets/ThreadLocal.html-3acedb59.js" as="script"><link rel="prefetch" href="/docs/assets/Hexo.html-39b07769.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-473f31aa.js" as="script"><link rel="prefetch" href="/docs/assets/Vue-CLI.html-93240fc1.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-28c9785b.js" as="script"><link rel="prefetch" href="/docs/assets/Beetl.html-ae29cf20.js" as="script"><link rel="prefetch" href="/docs/assets/ElasticSearch.html-de101f37.js" as="script"><link rel="prefetch" href="/docs/assets/Gateway.html-3bc2e986.js" as="script"><link rel="prefetch" href="/docs/assets/Jmeter.html-06cc8535.js" as="script"><link rel="prefetch" href="/docs/assets/MinIO.html-a607dc20.js" as="script"><link rel="prefetch" href="/docs/assets/RabbitMQ.html-465eef88.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-ee56f92a.js" as="script"><link rel="prefetch" href="/docs/assets/Seckill.html-4b6e543e.js" as="script"><link rel="prefetch" href="/docs/assets/Sentinel.html-08a81b56.js" as="script"><link rel="prefetch" href="/docs/assets/Sleuth.html-de2de160.js" as="script"><link rel="prefetch" href="/docs/assets/WebMagic.html-11abb935.js" as="script"><link rel="prefetch" href="/docs/assets/AQS.html-b0ded501.js" as="script"><link rel="prefetch" href="/docs/assets/Collection.html-028e08f0.js" as="script"><link rel="prefetch" href="/docs/assets/ConcurrentHashMap.html-46268d33.js" as="script"><link rel="prefetch" href="/docs/assets/HashMap.html-5a528887.js" as="script"><link rel="prefetch" href="/docs/assets/interview1.html-07daa0a2.js" as="script"><link rel="prefetch" href="/docs/assets/interview2.html-363a6772.js" as="script"><link rel="prefetch" href="/docs/assets/interview3.html-4a144ca4.js" as="script"><link rel="prefetch" href="/docs/assets/interview4.html-5a7602d4.js" as="script"><link rel="prefetch" href="/docs/assets/interview5.html-56ad55de.js" as="script"><link rel="prefetch" href="/docs/assets/interview6.html-2aeb0f2f.js" as="script"><link rel="prefetch" href="/docs/assets/interview7.html-e0e3cc6d.js" as="script"><link rel="prefetch" href="/docs/assets/interview8.html-51967c56.js" as="script"><link rel="prefetch" href="/docs/assets/interview9.html-814d72f6.js" as="script"><link rel="prefetch" href="/docs/assets/Java.html-e9e0859d.js" as="script"><link rel="prefetch" href="/docs/assets/JVM.html-c4af350e.js" as="script"><link rel="prefetch" href="/docs/assets/MQ.html-ec22ec4a.js" as="script"><link rel="prefetch" href="/docs/assets/Mybatis.html-7ed87fc9.js" as="script"><link rel="prefetch" href="/docs/assets/MySQL.html-59447878.js" as="script"><link rel="prefetch" href="/docs/assets/MySQL18.html-450ba9a7.js" as="script"><link rel="prefetch" href="/docs/assets/Netty.html-8ace40bf.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-c2e27e0b.js" as="script"><link rel="prefetch" href="/docs/assets/Redis.html-c44d9cb3.js" as="script"><link rel="prefetch" href="/docs/assets/Spring.html-7b4750d9.js" as="script"><link rel="prefetch" href="/docs/assets/Thread.html-83f810e9.js" as="script"><link rel="prefetch" href="/docs/assets/Mysql进阶.html-75ed9501.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-f62e01ac.js" as="script"><link rel="prefetch" href="/docs/assets/Docker.html-77176975.js" as="script"><link rel="prefetch" href="/docs/assets/Docker安装Redis.html-e4bd1acb.js" as="script"><link rel="prefetch" href="/docs/assets/linux.html-ee415c86.js" as="script"><link rel="prefetch" href="/docs/assets/Natapp内网穿透.html-a263295c.js" as="script"><link rel="prefetch" href="/docs/assets/PicGo.html-db960acc.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-4f0933fb.js" as="script"><link rel="prefetch" href="/docs/assets/Java实现参数校验的几种方式.html-90ddd013.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-0e69187b.js" as="script"><link rel="prefetch" href="/docs/assets/ThreadLocal.html-e427ca55.js" as="script"><link rel="prefetch" href="/docs/assets/Hexo.html-9b4b9a62.js" as="script"><link rel="prefetch" href="/docs/assets/index.html-29deb753.js" as="script"><link rel="prefetch" href="/docs/assets/Vue-CLI.html-5e8ecb86.js" as="script"><link rel="prefetch" href="/docs/assets/404.html-87d54bd8.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/docs/" class=""><img class="logo" src="/docs/images/logo.png" alt="StevenBlogs"><span class="site-name can-hide">StevenBlogs</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/docs/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/Vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/cloud/" class="" aria-label="Cloud"><!--[--><!--]--> Cloud <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/mysql/" class="" aria-label="Mysql"><!--[--><!--]--> Mysql <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/serverCloud/" class="" aria-label="ServerCloud"><!--[--><!--]--> ServerCloud <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/interview/" class="router-link-active" aria-label="Interview"><!--[--><!--]--> Interview <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Common websites"><span class="title">Common websites</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Common websites"><span class="title">Common websites</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://mvnrepository.com/" rel="noopener noreferrer" target="_blank" aria-label="Maven中央仓库"><!--[--><!--]--> Maven中央仓库 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.sojson.com/" rel="noopener noreferrer" target="_blank" aria-label="JSON解析"><!--[--><!--]--> JSON解析 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://pdfbox.apache.org/" rel="noopener noreferrer" target="_blank" aria-label="PDFBox"><!--[--><!--]--> PDFBox <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://npmmirror.com/" rel="noopener noreferrer" target="_blank" aria-label="NPM镜像站"><!--[--><!--]--> NPM镜像站 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://ghproxy.com/" rel="noopener noreferrer" target="_blank" aria-label="GitHub加速"><!--[--><!--]--> GitHub加速 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.bootcdn.cn/" rel="noopener noreferrer" target="_blank" aria-label="BootCDN"><!--[--><!--]--> BootCDN <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://hub.daocloud.io/" rel="noopener noreferrer" target="_blank" aria-label="DaoCloud"><!--[--><!--]--> DaoCloud <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://redisdoc.com/index.html" rel="noopener noreferrer" target="_blank" aria-label="Redis命令"><!--[--><!--]--> Redis命令 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://3.jetbra.in/" rel="noopener noreferrer" target="_blank" aria-label="JetBrain激活"><!--[--><!--]--> JetBrain激活 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://translate.google.cn/" rel="noopener noreferrer" target="_blank" aria-label="Google翻译"><!--[--><!--]--> Google翻译 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://c.runoob.com/front-end/854/" rel="noopener noreferrer" target="_blank" aria-label="正则在线工具"><!--[--><!--]--> 正则在线工具 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://developers.google.cn/" rel="noopener noreferrer" target="_blank" aria-label="Google开发者"><!--[--><!--]--> Google开发者 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/docs/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/Vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/cloud/" class="" aria-label="Cloud"><!--[--><!--]--> Cloud <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/mysql/" class="" aria-label="Mysql"><!--[--><!--]--> Mysql <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/serverCloud/" class="" aria-label="ServerCloud"><!--[--><!--]--> ServerCloud <!--[--><!--]--></a></div><div class="navbar-item"><a href="/docs/interview/" class="router-link-active" aria-label="Interview"><!--[--><!--]--> Interview <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Common websites"><span class="title">Common websites</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Common websites"><span class="title">Common websites</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://mvnrepository.com/" rel="noopener noreferrer" target="_blank" aria-label="Maven中央仓库"><!--[--><!--]--> Maven中央仓库 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.sojson.com/" rel="noopener noreferrer" target="_blank" aria-label="JSON解析"><!--[--><!--]--> JSON解析 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://pdfbox.apache.org/" rel="noopener noreferrer" target="_blank" aria-label="PDFBox"><!--[--><!--]--> PDFBox <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://npmmirror.com/" rel="noopener noreferrer" target="_blank" aria-label="NPM镜像站"><!--[--><!--]--> NPM镜像站 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://ghproxy.com/" rel="noopener noreferrer" target="_blank" aria-label="GitHub加速"><!--[--><!--]--> GitHub加速 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.bootcdn.cn/" rel="noopener noreferrer" target="_blank" aria-label="BootCDN"><!--[--><!--]--> BootCDN <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://hub.daocloud.io/" rel="noopener noreferrer" target="_blank" aria-label="DaoCloud"><!--[--><!--]--> DaoCloud <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://redisdoc.com/index.html" rel="noopener noreferrer" target="_blank" aria-label="Redis命令"><!--[--><!--]--> Redis命令 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://3.jetbra.in/" rel="noopener noreferrer" target="_blank" aria-label="JetBrain激活"><!--[--><!--]--> JetBrain激活 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://translate.google.cn/" rel="noopener noreferrer" target="_blank" aria-label="Google翻译"><!--[--><!--]--> Google翻译 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://c.runoob.com/front-end/854/" rel="noopener noreferrer" target="_blank" aria-label="正则在线工具"><!--[--><!--]--> 正则在线工具 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://developers.google.cn/" rel="noopener noreferrer" target="_blank" aria-label="Google开发者"><!--[--><!--]--> Google开发者 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="无量心经"><!--[--><!--]--> 无量心经 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#一-springcloud-微服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 SpringCloud 微服务"><!--[--><!--]--> 一 SpringCloud 微服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是微服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是微服务"><!--[--><!--]--> 1 什么是微服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-微服务框架的优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 微服务框架的优势"><!--[--><!--]--> 2 微服务框架的优势 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-springcloud-和微服务的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 SpringCloud 和微服务的关系"><!--[--><!--]--> 3 SpringCloud 和微服务的关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-springboot-和-springcloud-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 SpringBoot 和 SpringCloud 的区别"><!--[--><!--]--> 4 SpringBoot 和 SpringCloud 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-什么是-cap" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 什么是 CAP"><!--[--><!--]--> 5 什么是 CAP <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-naoca-注册中心" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 Naoca 注册中心"><!--[--><!--]--> 二 Naoca 注册中心 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-sentinel-熔断-降流" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 Sentinel 熔断 / 降流"><!--[--><!--]--> 三 Sentinel 熔断 / 降流 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-怎么设置降流" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 怎么设置降流"><!--[--><!--]--> 2 怎么设置降流 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-熔断" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 熔断"><!--[--><!--]--> 2 熔断 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-gateway-网关" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 Gateway 网关"><!--[--><!--]--> 四 Gateway 网关 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#五-seata-分布式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="五 Seata 分布式事务"><!--[--><!--]--> 五 Seata 分布式事务 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是分布式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是分布式事务"><!--[--><!--]--> 1 什么是分布式事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-而在seata中有at、tcc、saga和-xa-事务模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 而在seata中有AT、TCC、SAGA和 XA 事务模式"><!--[--><!--]--> 2 而在seata中有AT、TCC、SAGA和 XA 事务模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#六分布式锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="六分布式锁"><!--[--><!--]--> 六分布式锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-rabbitmq" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 RabbitMQ"><!--[--><!--]--> 一 RabbitMQ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-mq-的模式有那些" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  MQ 的模式有那些"><!--[--><!--]--> 3  MQ 的模式有那些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-mq-怎么确保消息的可靠性" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  MQ 怎么确保消息的可靠性"><!--[--><!--]--> 4  MQ 怎么确保消息的可靠性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#可以采用持久化机制-手动ack" class="router-link-active router-link-exact-active sidebar-item" aria-label="可以采用持久化机制+手动ACK"><!--[--><!--]--> 可以采用持久化机制+手动ACK <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-开启持久化" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 开启持久化"><!--[--><!--]--> 1 开启持久化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-mq-怎么避免消息重复消费-幂等性" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  MQ 怎么避免消息重复消费（幂等性）"><!--[--><!--]--> 5  MQ 怎么避免消息重复消费（幂等性） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-怎么实现延迟队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 怎么实现延迟队列"><!--[--><!--]--> 6 怎么实现延迟队列 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#ttl-死信队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="TTL+ 死信队列"><!--[--><!--]--> TTL+ 死信队列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能"><!--[--><!--]--> 通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-redis-nosql" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 Redis （ NoSql ）"><!--[--><!--]--> 二 Redis （ NoSql ） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-为什么使用-redis-使用-redis-的好处" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 为什么使用 redis ，使用 redis 的好处"><!--[--><!--]--> 1 为什么使用 redis ，使用 redis 的好处 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-速度快-因为数据存储再内存中" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 速度快，因为数据存储再内存中"><!--[--><!--]--> 1 速度快，因为数据存储再内存中 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-rdb-和-aof-的持久化机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  Rdb 和 Aof 的持久化机制"><!--[--><!--]--> 2  Rdb 和 Aof 的持久化机制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" class="router-link-active router-link-exact-active sidebar-item" aria-label="持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失"><!--[--><!--]--> 持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-怎么保证-redis-和数据库的一致性" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 怎么保证 redis 和数据库的一致性"><!--[--><!--]--> 3 怎么保证 redis 和数据库的一致性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-合理的设置缓存过期时间" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 合理的设置缓存过期时间"><!--[--><!--]--> 1 合理的设置缓存过期时间 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-redis-缓存穿透-缓存雪崩-缓存击穿" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  redis 缓存穿透，缓存雪崩，缓存击穿"><!--[--><!--]--> 4  redis 缓存穿透，缓存雪崩，缓存击穿 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-redis-如何实现高并发、高可用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  redis 如何实现高并发、高可用"><!--[--><!--]--> 5  redis 如何实现高并发、高可用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" class="router-link-active router-link-exact-active sidebar-item" aria-label="高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发"><!--[--><!--]--> 高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" class="router-link-active router-link-exact-active sidebar-item" aria-label="高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点"><!--[--><!--]--> 高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-redis-的性能优化-和解决方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  redis 的性能优化，和解决方案"><!--[--><!--]--> 6  redis 的性能优化，和解决方案 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-redis-的-trdlock-红锁的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  redis 的 TrdLock 红锁的实现"><!--[--><!--]--> 7  redis 的 TrdLock 红锁的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_8-redis-的过期策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="8  redis 的过期策略"><!--[--><!--]--> 8  redis 的过期策略 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-mybatis" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 Mybatis"><!--[--><!--]--> 三 Mybatis <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mybatis-的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mybatis 的优缺点"><!--[--><!--]--> 1  mybatis 的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性"><!--[--><!--]--> 优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mybatis-的-1-2-级缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mybatis 的 1 ， 2 级缓存"><!--[--><!--]--> 2  mybatis 的 1 ， 2 级缓存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-spring" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 Spring"><!--[--><!--]--> 一 Spring <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-为什么使用-spring" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 为什么使用 spring"><!--[--><!--]--> 1 为什么使用 spring <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-什么是-aop-ioc" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 什么是 Aop ， Ioc"><!--[--><!--]--> 2 什么是 Aop ， Ioc <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-spring-的注入方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  spring 的注入方式"><!--[--><!--]--> 3  spring 的注入方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-springbean-的声命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  springBean 的声命周期"><!--[--><!--]--> 4  springBean 的声命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-spring-的自动装配" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  spring 的自动装配"><!--[--><!--]--> 5  spring 的自动装配 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#容器不会自动装配" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器不会自动装配"><!--[--><!--]--> 容器不会自动装配 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-spring-框架用到了那些设计模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  spring 框架用到了那些设计模式"><!--[--><!--]--> 6  spring 框架用到了那些设计模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-spring-的事务性" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  spring 的事务性"><!--[--><!--]--> 7  spring 的事务性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现"><!--[--><!--]--> 可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-springmvc" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 SpringMVC"><!--[--><!--]--> 二 SpringMVC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是-springmvc" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是 springMvc"><!--[--><!--]--> 1 什么是 springMvc <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mvc-有那些组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  MVC 有那些组件"><!--[--><!--]--> 2  MVC 有那些组件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-springboot" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 SpringBoot"><!--[--><!--]--> 三 SpringBoot <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是-springboot-你对-springboot-的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是 springBoot/ 你对 springBoot 的理解"><!--[--><!--]--> 1 什么是 springBoot/ 你对 springBoot 的理解 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架"><!--[--><!--]--> 1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-springboot-的配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  springBoot 的配置"><!--[--><!--]--> 2  springBoot 的配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-springbootapplication-的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  SpringBootApplication 的作用"><!--[--><!--]--> 3  SpringBootApplication 的作用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#放在启动了上、、、此注解中包含三个注解" class="router-link-active router-link-exact-active sidebar-item" aria-label="放在启动了上、、、此注解中包含三个注解"><!--[--><!--]--> 放在启动了上、、、此注解中包含三个注解 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-spring-、-springmvc-、-springboot-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 spring 、 springMVC 、 springBoot 区别"><!--[--><!--]--> 四 spring 、 springMVC 、 springBoot 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-sql-基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 sql 基础"><!--[--><!--]--> 一 sql 基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mysql-四大操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mysql 四大操作"><!--[--><!--]--> 1  mysql 四大操作 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#crud" class="router-link-active router-link-exact-active sidebar-item" aria-label="CRUD"><!--[--><!--]--> CRUD <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mysql-常用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mysql 常用类型"><!--[--><!--]--> 2  mysql 常用类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-mysql-常用关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  mysql 常用关键字"><!--[--><!--]--> 3  mysql 常用关键字 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-mysql-常用函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  mysql 常用函数"><!--[--><!--]--> 4  mysql 常用函数 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#聚合函数、日期函数、字符串函数、数值函数、流程控制函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="聚合函数、日期函数、字符串函数、数值函数、流程控制函数"><!--[--><!--]--> 聚合函数、日期函数、字符串函数、数值函数、流程控制函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-聚合函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 聚合函数"><!--[--><!--]--> 1 聚合函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-时间函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 时间函数"><!--[--><!--]--> 2 时间函数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-sql-事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 sql 事务"><!--[--><!--]--> 二 sql 事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-数据库的三大范氏" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 数据库的三大范氏"><!--[--><!--]--> 1 数据库的三大范氏 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#第一范氏-数据库的每一列都是不可分割的原子数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="第一范氏：数据库的每一列都是不可分割的原子数据"><!--[--><!--]--> 第一范氏：数据库的每一列都是不可分割的原子数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用"><!--[--><!--]--> 例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第二范氏-实体的属性不能完全依赖于主关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="第二范氏：实体的属性不能完全依赖于主关键字"><!--[--><!--]--> 第二范氏：实体的属性不能完全依赖于主关键字 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第三范氏-任何非主属性不依赖于其他主属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="第三范氏：任何非主属性不依赖于其他主属性"><!--[--><!--]--> 第三范氏：任何非主属性不依赖于其他主属性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第四范氏-一张表中-尽量不要使用多对多的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="第四范氏：一张表中，尽量不要使用多对多的关系"><!--[--><!--]--> 第四范氏：一张表中，尽量不要使用多对多的关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第五范氏-从最终结构重新建立原始结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="第五范氏：从最终结构重新建立原始结构"><!--[--><!--]--> 第五范氏：从最终结构重新建立原始结构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-事务的四大特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 事务的四大特性"><!--[--><!--]--> 2 事务的四大特性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#acid" class="router-link-active router-link-exact-active sidebar-item" aria-label="ACID"><!--[--><!--]--> ACID <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#时开启的同时互不干扰-相互隔离" class="router-link-active router-link-exact-active sidebar-item" aria-label="时开启的同时互不干扰，相互隔离"><!--[--><!--]--> 时开启的同时互不干扰，相互隔离 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-事务的并发问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 事务的并发问题"><!--[--><!--]--> 3 事务的并发问题 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到"><!--[--><!--]--> 1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致"><!--[--><!--]--> 2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致"><!--[--><!--]--> 3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-事务的隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 事务的隔离级别"><!--[--><!--]--> 4 事务的隔离级别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取"><!--[--><!--]--> 1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-但是会出现脏读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，但是会出现脏读"><!--[--><!--]--> 解决了事务更新丢失，但是会出现脏读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-读提交-第一个事务读取-其他数据可以进行读写操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 读提交：第一个事务读取，其他数据可以进行读写操作"><!--[--><!--]--> 2 读提交：第一个事务读取，其他数据可以进行读写操作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-但是可能出现不可重复读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，但是可能出现不可重复读"><!--[--><!--]--> 解决了事务更新丢失，脏读，但是可能出现不可重复读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写"><!--[--><!--]--> 3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，不可重复读，但是会出现幻读"><!--[--><!--]--> 解决了事务更新丢失，脏读，不可重复读，但是会出现幻读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行）"><!--[--><!--]--> 4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-不可重复的-幻读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，不可重复的，幻读"><!--[--><!--]--> 解决了事务更新丢失，脏读，不可重复的，幻读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#事务排队执行-但是性能低-一般不会被使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="事务排队执行，但是性能低，一般不会被使用"><!--[--><!--]--> 事务排队执行，但是性能低，一般不会被使用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-sql-索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 sql 索引"><!--[--><!--]--> 三 sql 索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是索引"><!--[--><!--]--> 1 什么是索引 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引是数据库的一个排序的数据结构，索引使用B树，B+树实现"><!--[--><!--]--> 索引是数据库的一个排序的数据结构，索引使用B树，B+树实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-索引的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 索引的作用"><!--[--><!--]--> 2 索引的作用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#快速查找-更新表中数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="快速查找，更新表中数据"><!--[--><!--]--> 快速查找，更新表中数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#代价-数据库存储空间增加-插入和修改花费时间较多" class="router-link-active router-link-exact-active sidebar-item" aria-label="代价：数据库存储空间增加，插入和修改花费时间较多"><!--[--><!--]--> 代价：数据库存储空间增加，插入和修改花费时间较多 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-索引的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 索引的分类"><!--[--><!--]--> 3 索引的分类 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-普通索引-仅加速查询" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 普通索引：仅加速查询"><!--[--><!--]--> 1 普通索引：仅加速查询 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-索引的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 索引的优缺点"><!--[--><!--]--> 4 索引的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点-可以大大的提升性能" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：可以大大的提升性能"><!--[--><!--]--> 优点：可以大大的提升性能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-唯一索引-可以保证每一行数据的唯一性" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 唯一索引：可以保证每一行数据的唯一性"><!--[--><!--]--> 1 唯一索引：可以保证每一行数据的唯一性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-提升了数据的检索速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 提升了数据的检索速度"><!--[--><!--]--> 2 提升了数据的检索速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-可以加速表与表之间的连接" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 可以加速表与表之间的连接"><!--[--><!--]--> 3 可以加速表与表之间的连接 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-查询速度快" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 查询速度快"><!--[--><!--]--> 4 查询速度快 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点"><!--[--><!--]--> 缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度"><!--[--><!--]--> 1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大）"><!--[--><!--]--> 2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-维护索引时间增加" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 维护索引时间增加"><!--[--><!--]--> 3 维护索引时间增加 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-b-树和-b-树" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  B 树和 B+ 树"><!--[--><!--]--> 5  B 树和 B+ 树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-mysql-的存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 mysql 的存储引擎"><!--[--><!--]--> 四 mysql 的存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mysql-的存储引擎有那些" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mysql 的存储引擎有那些"><!--[--><!--]--> 1  mysql 的存储引擎有那些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mysql-的存储过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mysql 的存储过程"><!--[--><!--]--> 2  mysql 的存储过程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用"><!--[--><!--]--> 存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可以使用一个命令对象调用存储过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可以使用一个命令对象调用存储过程"><!--[--><!--]--> 1 可以使用一个命令对象调用存储过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-存储过程的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 存储过程的优缺点"><!--[--><!--]--> 3 存储过程的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点"><!--[--><!--]--> 优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-存储过程是预编译过的-执行效率高" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 存储过程是预编译过的，执行效率高"><!--[--><!--]--> 1 存储过程是预编译过的，执行效率高 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信）"><!--[--><!--]--> 2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-安全性高-需要有一定权限的用户执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 安全性高，需要有一定权限的用户执行"><!--[--><!--]--> 3 安全性高，需要有一定权限的用户执行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-可以重复使用-减少代码量" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 可以重复使用，减少代码量"><!--[--><!--]--> 4 可以重复使用，减少代码量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-移植性差" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：移植性差"><!--[--><!--]--> 缺点：移植性差 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#五-sql-优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="五 sql 优化"><!--[--><!--]--> 五 sql 优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-怎么查找需要优化的数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 怎么查找需要优化的数据"><!--[--><!--]--> 1 怎么查找需要优化的数据 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#定位——分析——解决" class="router-link-active router-link-exact-active sidebar-item" aria-label="定位——分析——解决"><!--[--><!--]--> 定位——分析——解决 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#一内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="一内存"><!--[--><!--]--> 一内存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-类加载的过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 类加载的过程"><!--[--><!--]--> 1 类加载的过程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#加载——校验——准备——解析——初始化——使用——卸载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载——校验——准备——解析——初始化——使用——卸载"><!--[--><!--]--> 加载——校验——准备——解析——初始化——使用——卸载 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-java-中类的声明周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  java 中类的声明周期"><!--[--><!--]--> 2  java 中类的声明周期 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#加载——连接——初始化——使用——卸载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载——连接——初始化——使用——卸载"><!--[--><!--]--> 加载——连接——初始化——使用——卸载 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-什么是双亲委派模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 什么是双亲委派模型"><!--[--><!--]--> 3 什么是双亲委派模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#双亲委派模型是一个类的加载过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="双亲委派模型是一个类的加载过程"><!--[--><!--]--> 双亲委派模型是一个类的加载过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" class="router-link-active router-link-exact-active sidebar-item" aria-label="一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父"><!--[--><!--]--> 一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载"><!--[--><!--]--> 加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#优点-防止内存中出现多份同样的字节码" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：防止内存中出现多份同样的字节码"><!--[--><!--]--> 优点：防止内存中出现多份同样的字节码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-堆和栈道区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 堆和栈道区别"><!--[--><!--]--> 4 堆和栈道区别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#栈-内存用来存储局部变量和方法的调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="栈：内存用来存储局部变量和方法的调用"><!--[--><!--]--> 栈：内存用来存储局部变量和方法的调用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-cg-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 CG 算法"><!--[--><!--]--> 二 CG 算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-jvm-有那些垃圾回收算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  JVM 有那些垃圾回收算法"><!--[--><!--]--> 1  JVM 有那些垃圾回收算法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#标记-清除算法——标记-整理算法——复制算法——分代算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="标记-清除算法——标记-整理算法——复制算法——分代算法"><!--[--><!--]--> 标记-清除算法——标记-整理算法——复制算法——分代算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-标记-清除算法-标记无用的对象-然后进行清除回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 标记-清除算法：标记无用的对象，然后进行清除回收"><!--[--><!--]--> 1 标记-清除算法：标记无用的对象，然后进行清除回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-效率不高-无法清除垃圾碎片" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：效率不高，无法清除垃圾碎片"><!--[--><!--]--> 缺点：效率不高，无法清除垃圾碎片 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存"><!--[--><!--]--> 2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后"><!--[--><!--]--> 3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#将或者的对象复制到另一个区域中-再清除用完的区域" class="router-link-active router-link-exact-active sidebar-item" aria-label="将或者的对象复制到另一个区域中，再清除用完的区域"><!--[--><!--]--> 将或者的对象复制到另一个区域中，再清除用完的区域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-内存使用率低-只有原来的一般空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：内存使用率低，只有原来的一般空间"><!--[--><!--]--> 缺点：内存使用率低，只有原来的一般空间 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代"><!--[--><!--]--> 4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#新生代一般采用复制算法-老年代一般采用标记整理算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="新生代一般采用复制算法，老年代一般采用标记整理算法"><!--[--><!--]--> 新生代一般采用复制算法，老年代一般采用标记整理算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-jvm-的垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  JVM 的垃圾回收器"><!--[--><!--]--> 2  JVM 的垃圾回收器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#常用-cms、g-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用：CMS、G 1"><!--[--><!--]--> 常用：CMS、G 1 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-cms-垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  CMS 垃圾回收器"><!--[--><!--]--> 3  CMS 垃圾回收器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" class="router-link-active router-link-exact-active sidebar-item" aria-label="CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片"><!--[--><!--]--> CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-新生代和老年代的垃圾回收期有哪些-有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 新生代和老年代的垃圾回收期有哪些，有什么区别"><!--[--><!--]--> 4 新生代和老年代的垃圾回收期有哪些，有什么区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-垃圾回收器是怎么工作的" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 垃圾回收器是怎么工作的"><!--[--><!--]--> 5 垃圾回收器是怎么工作的 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间）"><!--[--><!--]--> 分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-新生代-使用的是复制算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 新生代：使用的是复制算法"><!--[--><!--]--> 1 新生代：使用的是复制算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法"><!--[--><!--]--> 2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-java-中有那些引用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  java 中有那些引用类型"><!--[--><!--]--> 6  java 中有那些引用类型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#强引用——软引用——弱引用——虚引用" class="router-link-active router-link-exact-active sidebar-item" aria-label="强引用——软引用——弱引用——虚引用"><!--[--><!--]--> 强引用——软引用——弱引用——虚引用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-强引用-发生gc时不会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 强引用：发生GC时不会被回收"><!--[--><!--]--> 1 强引用：发生GC时不会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收"><!--[--><!--]--> 2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收"><!--[--><!--]--> 3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知"><!--[--><!--]--> 4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-gc-的触发条件" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  GC 的触发条件"><!--[--><!--]--> 7  GC 的触发条件 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#老年区空间不足、方法区空间不足、" class="router-link-active router-link-exact-active sidebar-item" aria-label="老年区空间不足、方法区空间不足、"><!--[--><!--]--> 老年区空间不足、方法区空间不足、 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#当复制算法等-进入老年代时平均大小大于老年代的空间时" class="router-link-active router-link-exact-active sidebar-item" aria-label="当复制算法等，进入老年代时平均大小大于老年代的空间时"><!--[--><!--]--> 当复制算法等，进入老年代时平均大小大于老年代的空间时 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#一线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="一线程"><!--[--><!--]--> 一线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-进程和线程的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 进程和线程的区别"><!--[--><!--]--> 1 进程和线程的区别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#进程-应用程序执行的实例-有独立的内存空间和系统资源" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程：应用程序执行的实例，有独立的内存空间和系统资源"><!--[--><!--]--> 进程：应用程序执行的实例，有独立的内存空间和系统资源 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#线程-cpu调度和分派的基本单位-应用程序是最小的单位" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程：CPU调度和分派的基本单位，应用程序是最小的单位"><!--[--><!--]--> 线程：CPU调度和分派的基本单位，应用程序是最小的单位 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-线程的状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 线程的状态"><!--[--><!--]--> 2 线程的状态 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#创建线程——就绪状态——运行状态——阻塞状态——死亡状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="创建线程——就绪状态——运行状态——阻塞状态——死亡状态"><!--[--><!--]--> 创建线程——就绪状态——运行状态——阻塞状态——死亡状态 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-常用方法-调度" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 常用方法（调度）"><!--[--><!--]--> 3 常用方法（调度） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-线程的有点" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 线程的有点"><!--[--><!--]--> 4 线程的有点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可重复使用存在的线程-减少对象创建销毁的开销" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可重复使用存在的线程，减少对象创建销毁的开销"><!--[--><!--]--> 1 可重复使用存在的线程，减少对象创建销毁的开销 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 提高系统资源的使用率，避免多资源竞争，避免阻塞"><!--[--><!--]--> 2 提高系统资源的使用率，避免多资源竞争，避免阻塞 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-提供定时-定期执行-单线程、并发等控制功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 提供定时，定期执行，单线程、并发等控制功能"><!--[--><!--]--> 3 提供定时，定期执行，单线程、并发等控制功能 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-实现多线程的几种方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 实现多线程的几种方法"><!--[--><!--]--> 5 实现多线程的几种方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-创建线程池的几种方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 创建线程池的几种方法"><!--[--><!--]--> 6 创建线程池的几种方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-线程池的状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 线程池的状态"><!--[--><!--]--> 7 线程池的状态 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_8-线程池中-submit-和-execute-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="8 线程池中 submit （）和 execute 的区别"><!--[--><!--]--> 8 线程池中 submit （）和 execute 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_9-线程池的七大核心参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 线程池的七大核心参数"><!--[--><!--]--> 9 线程池的七大核心参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二线程安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="二线程安全"><!--[--><!--]--> 二线程安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-java-中怎么保证线程的安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  Java 中怎么保证线程的安全"><!--[--><!--]--> 1  Java 中怎么保证线程的安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-什么是死锁-怎么防止" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 什么是死锁，怎么防止"><!--[--><!--]--> 2 什么是死锁，怎么防止 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进"><!--[--><!--]--> 死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#就会造成死锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="就会造成死锁"><!--[--><!--]--> 就会造成死锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-synchronized-的底层实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  synchronized 的底层实现原理"><!--[--><!--]--> 3  synchronized 的底层实现原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" class="router-link-active router-link-exact-active sidebar-item" aria-label="每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候"><!--[--><!--]--> 每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#尝试获取锁的每个对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="尝试获取锁的每个对象"><!--[--><!--]--> 尝试获取锁的每个对象 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-synchronized-和-lock-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  synchronized 和 lock 的区别"><!--[--><!--]--> 4  synchronized 和 lock 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-锁的类别" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 锁的类别"><!--[--><!--]--> 5 锁的类别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="一容器"><!--[--><!--]--> 一容器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-java-中有那些容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  java 中有那些容器"><!--[--><!--]--> 1  java 中有那些容器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-5-大容器的特点、用法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 5 大容器的特点、用法"><!--[--><!--]--> 2 5 大容器的特点、用法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-那些容器是安全的-那些不安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 那些容器是安全的，那些不安全"><!--[--><!--]--> 3 那些容器是安全的，那些不安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-java-基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 java 基础"><!--[--><!--]--> 二 java 基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-sring-的常用方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  Sring 的常用方法"><!--[--><!--]--> 1  Sring 的常用方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-final-关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  final 关键字"><!--[--><!--]--> 2  final 关键字 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#修饰类-不能被继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰类：不能被继承"><!--[--><!--]--> 修饰类：不能被继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#修饰方法-不能被重写" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰方法：不能被重写"><!--[--><!--]--> 修饰方法：不能被重写 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#修饰变量-不能被修改" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰变量：不能被修改"><!--[--><!--]--> 修饰变量：不能被修改 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-方法重写和重载" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 方法重写和重载"><!--[--><!--]--> 3 方法重写和重载 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#重写-参数名、方法名、返回值必须保持一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="重写：参数名、方法名、返回值必须保持一致"><!--[--><!--]--> 重写：参数名、方法名、返回值必须保持一致 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-stringbuilder-、-stringbuffer-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  StringBuilder 、 StringBuffer 区别"><!--[--><!--]--> 4  StringBuilder 、 StringBuffer 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-为什么重写-equals-必须重写-hashcode-方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 为什么重写 equals 必须重写 hashCode 方法"><!--[--><!--]--> 5 为什么重写 equals 必须重写 hashCode 方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-数组在内存中如何分配" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 数组在内存中如何分配"><!--[--><!--]--> 6 数组在内存中如何分配 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-java-中的四大引用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  java 中的四大引用类型"><!--[--><!--]--> 7  java 中的四大引用类型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#强引用——软引用——弱引用——虚引用-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="强引用——软引用——弱引用——虚引用"><!--[--><!--]--> 强引用——软引用——弱引用——虚引用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/docs/interview/Java.html" class="sidebar-item sidebar-heading" aria-label="Java基础面试题"><!--[--><!--]--> Java基础面试题 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/Collection.html" class="sidebar-item sidebar-heading" aria-label="Java集合高频面试题"><!--[--><!--]--> Java集合高频面试题 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/HashMap.html" class="sidebar-item sidebar-heading" aria-label="HashMap有哪些问题？"><!--[--><!--]--> HashMap有哪些问题？ <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/ConcurrentHashMap.html" class="sidebar-item sidebar-heading" aria-label="ConcurrentHashMap"><!--[--><!--]--> ConcurrentHashMap <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/JVM.html" class="sidebar-item sidebar-heading" aria-label="JVM 常考面试题"><!--[--><!--]--> JVM 常考面试题 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/Thread.html" class="sidebar-item sidebar-heading" aria-label="Java 并发"><!--[--><!--]--> Java 并发 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/AQS.html" class="sidebar-item sidebar-heading" aria-label="AQS"><!--[--><!--]--> AQS <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/MySQL.html" class="sidebar-item sidebar-heading" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/MySQL18.html" class="sidebar-item sidebar-heading" aria-label="MYSQL索引连环18问"><!--[--><!--]--> MYSQL索引连环18问 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/Redis.html" class="sidebar-item sidebar-heading" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/Spring.html" class="sidebar-item sidebar-heading" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/Mybatis.html" class="sidebar-item sidebar-heading" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/MQ.html" class="sidebar-item sidebar-heading" aria-label="MQ"><!--[--><!--]--> MQ <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview1.html" class="sidebar-item sidebar-heading" aria-label="基础题-精简版"><!--[--><!--]--> 基础题-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview2.html" class="sidebar-item sidebar-heading" aria-label="集合题-精简版"><!--[--><!--]--> 集合题-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview3.html" class="sidebar-item sidebar-heading" aria-label="Spring-精简版"><!--[--><!--]--> Spring-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview4.html" class="sidebar-item sidebar-heading" aria-label="MyBatis&amp;MQ-精简版"><!--[--><!--]--> MyBatis&amp;MQ-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview5.html" class="sidebar-item sidebar-heading" aria-label="Redis-精简版"><!--[--><!--]--> Redis-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview6.html" class="sidebar-item sidebar-heading" aria-label="MySQL-精简版"><!--[--><!--]--> MySQL-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview7.html" class="sidebar-item sidebar-heading" aria-label="JVM-精简版"><!--[--><!--]--> JVM-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview8.html" class="sidebar-item sidebar-heading" aria-label="JAVA并发-精简版"><!--[--><!--]--> JAVA并发-精简版 <!--[--><!--]--></a><!----></li><li><a href="/docs/interview/interview9.html" class="sidebar-item sidebar-heading" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="无量心经"><!--[--><!--]--> 无量心经 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#一-springcloud-微服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 SpringCloud 微服务"><!--[--><!--]--> 一 SpringCloud 微服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是微服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是微服务"><!--[--><!--]--> 1 什么是微服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-微服务框架的优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 微服务框架的优势"><!--[--><!--]--> 2 微服务框架的优势 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-springcloud-和微服务的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 SpringCloud 和微服务的关系"><!--[--><!--]--> 3 SpringCloud 和微服务的关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-springboot-和-springcloud-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 SpringBoot 和 SpringCloud 的区别"><!--[--><!--]--> 4 SpringBoot 和 SpringCloud 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-什么是-cap" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 什么是 CAP"><!--[--><!--]--> 5 什么是 CAP <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-naoca-注册中心" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 Naoca 注册中心"><!--[--><!--]--> 二 Naoca 注册中心 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-sentinel-熔断-降流" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 Sentinel 熔断 / 降流"><!--[--><!--]--> 三 Sentinel 熔断 / 降流 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-怎么设置降流" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 怎么设置降流"><!--[--><!--]--> 2 怎么设置降流 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-熔断" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 熔断"><!--[--><!--]--> 2 熔断 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-gateway-网关" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 Gateway 网关"><!--[--><!--]--> 四 Gateway 网关 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#五-seata-分布式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="五 Seata 分布式事务"><!--[--><!--]--> 五 Seata 分布式事务 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是分布式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是分布式事务"><!--[--><!--]--> 1 什么是分布式事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-而在seata中有at、tcc、saga和-xa-事务模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 而在seata中有AT、TCC、SAGA和 XA 事务模式"><!--[--><!--]--> 2 而在seata中有AT、TCC、SAGA和 XA 事务模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#六分布式锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="六分布式锁"><!--[--><!--]--> 六分布式锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-rabbitmq" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 RabbitMQ"><!--[--><!--]--> 一 RabbitMQ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-mq-的模式有那些" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  MQ 的模式有那些"><!--[--><!--]--> 3  MQ 的模式有那些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-mq-怎么确保消息的可靠性" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  MQ 怎么确保消息的可靠性"><!--[--><!--]--> 4  MQ 怎么确保消息的可靠性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#可以采用持久化机制-手动ack" class="router-link-active router-link-exact-active sidebar-item" aria-label="可以采用持久化机制+手动ACK"><!--[--><!--]--> 可以采用持久化机制+手动ACK <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-开启持久化" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 开启持久化"><!--[--><!--]--> 1 开启持久化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-mq-怎么避免消息重复消费-幂等性" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  MQ 怎么避免消息重复消费（幂等性）"><!--[--><!--]--> 5  MQ 怎么避免消息重复消费（幂等性） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-怎么实现延迟队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 怎么实现延迟队列"><!--[--><!--]--> 6 怎么实现延迟队列 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#ttl-死信队列" class="router-link-active router-link-exact-active sidebar-item" aria-label="TTL+ 死信队列"><!--[--><!--]--> TTL+ 死信队列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能"><!--[--><!--]--> 通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-redis-nosql" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 Redis （ NoSql ）"><!--[--><!--]--> 二 Redis （ NoSql ） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-为什么使用-redis-使用-redis-的好处" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 为什么使用 redis ，使用 redis 的好处"><!--[--><!--]--> 1 为什么使用 redis ，使用 redis 的好处 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-速度快-因为数据存储再内存中" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 速度快，因为数据存储再内存中"><!--[--><!--]--> 1 速度快，因为数据存储再内存中 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-rdb-和-aof-的持久化机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  Rdb 和 Aof 的持久化机制"><!--[--><!--]--> 2  Rdb 和 Aof 的持久化机制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" class="router-link-active router-link-exact-active sidebar-item" aria-label="持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失"><!--[--><!--]--> 持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-怎么保证-redis-和数据库的一致性" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 怎么保证 redis 和数据库的一致性"><!--[--><!--]--> 3 怎么保证 redis 和数据库的一致性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-合理的设置缓存过期时间" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 合理的设置缓存过期时间"><!--[--><!--]--> 1 合理的设置缓存过期时间 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-redis-缓存穿透-缓存雪崩-缓存击穿" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  redis 缓存穿透，缓存雪崩，缓存击穿"><!--[--><!--]--> 4  redis 缓存穿透，缓存雪崩，缓存击穿 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-redis-如何实现高并发、高可用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  redis 如何实现高并发、高可用"><!--[--><!--]--> 5  redis 如何实现高并发、高可用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" class="router-link-active router-link-exact-active sidebar-item" aria-label="高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发"><!--[--><!--]--> 高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" class="router-link-active router-link-exact-active sidebar-item" aria-label="高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点"><!--[--><!--]--> 高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-redis-的性能优化-和解决方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  redis 的性能优化，和解决方案"><!--[--><!--]--> 6  redis 的性能优化，和解决方案 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-redis-的-trdlock-红锁的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  redis 的 TrdLock 红锁的实现"><!--[--><!--]--> 7  redis 的 TrdLock 红锁的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_8-redis-的过期策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="8  redis 的过期策略"><!--[--><!--]--> 8  redis 的过期策略 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-mybatis" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 Mybatis"><!--[--><!--]--> 三 Mybatis <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mybatis-的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mybatis 的优缺点"><!--[--><!--]--> 1  mybatis 的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性"><!--[--><!--]--> 优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mybatis-的-1-2-级缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mybatis 的 1 ， 2 级缓存"><!--[--><!--]--> 2  mybatis 的 1 ， 2 级缓存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-spring" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 Spring"><!--[--><!--]--> 一 Spring <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-为什么使用-spring" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 为什么使用 spring"><!--[--><!--]--> 1 为什么使用 spring <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-什么是-aop-ioc" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 什么是 Aop ， Ioc"><!--[--><!--]--> 2 什么是 Aop ， Ioc <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-spring-的注入方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  spring 的注入方式"><!--[--><!--]--> 3  spring 的注入方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-springbean-的声命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  springBean 的声命周期"><!--[--><!--]--> 4  springBean 的声命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-spring-的自动装配" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  spring 的自动装配"><!--[--><!--]--> 5  spring 的自动装配 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#容器不会自动装配" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器不会自动装配"><!--[--><!--]--> 容器不会自动装配 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-spring-框架用到了那些设计模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  spring 框架用到了那些设计模式"><!--[--><!--]--> 6  spring 框架用到了那些设计模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-spring-的事务性" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  spring 的事务性"><!--[--><!--]--> 7  spring 的事务性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现"><!--[--><!--]--> 可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-springmvc" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 SpringMVC"><!--[--><!--]--> 二 SpringMVC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是-springmvc" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是 springMvc"><!--[--><!--]--> 1 什么是 springMvc <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mvc-有那些组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  MVC 有那些组件"><!--[--><!--]--> 2  MVC 有那些组件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-springboot" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 SpringBoot"><!--[--><!--]--> 三 SpringBoot <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是-springboot-你对-springboot-的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是 springBoot/ 你对 springBoot 的理解"><!--[--><!--]--> 1 什么是 springBoot/ 你对 springBoot 的理解 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架"><!--[--><!--]--> 1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-springboot-的配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  springBoot 的配置"><!--[--><!--]--> 2  springBoot 的配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-springbootapplication-的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  SpringBootApplication 的作用"><!--[--><!--]--> 3  SpringBootApplication 的作用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#放在启动了上、、、此注解中包含三个注解" class="router-link-active router-link-exact-active sidebar-item" aria-label="放在启动了上、、、此注解中包含三个注解"><!--[--><!--]--> 放在启动了上、、、此注解中包含三个注解 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-spring-、-springmvc-、-springboot-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 spring 、 springMVC 、 springBoot 区别"><!--[--><!--]--> 四 spring 、 springMVC 、 springBoot 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一-sql-基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="一 sql 基础"><!--[--><!--]--> 一 sql 基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mysql-四大操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mysql 四大操作"><!--[--><!--]--> 1  mysql 四大操作 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#crud" class="router-link-active router-link-exact-active sidebar-item" aria-label="CRUD"><!--[--><!--]--> CRUD <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mysql-常用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mysql 常用类型"><!--[--><!--]--> 2  mysql 常用类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-mysql-常用关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  mysql 常用关键字"><!--[--><!--]--> 3  mysql 常用关键字 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-mysql-常用函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  mysql 常用函数"><!--[--><!--]--> 4  mysql 常用函数 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#聚合函数、日期函数、字符串函数、数值函数、流程控制函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="聚合函数、日期函数、字符串函数、数值函数、流程控制函数"><!--[--><!--]--> 聚合函数、日期函数、字符串函数、数值函数、流程控制函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-聚合函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 聚合函数"><!--[--><!--]--> 1 聚合函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-时间函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 时间函数"><!--[--><!--]--> 2 时间函数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-sql-事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 sql 事务"><!--[--><!--]--> 二 sql 事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-数据库的三大范氏" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 数据库的三大范氏"><!--[--><!--]--> 1 数据库的三大范氏 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#第一范氏-数据库的每一列都是不可分割的原子数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="第一范氏：数据库的每一列都是不可分割的原子数据"><!--[--><!--]--> 第一范氏：数据库的每一列都是不可分割的原子数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用"><!--[--><!--]--> 例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第二范氏-实体的属性不能完全依赖于主关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="第二范氏：实体的属性不能完全依赖于主关键字"><!--[--><!--]--> 第二范氏：实体的属性不能完全依赖于主关键字 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第三范氏-任何非主属性不依赖于其他主属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="第三范氏：任何非主属性不依赖于其他主属性"><!--[--><!--]--> 第三范氏：任何非主属性不依赖于其他主属性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第四范氏-一张表中-尽量不要使用多对多的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="第四范氏：一张表中，尽量不要使用多对多的关系"><!--[--><!--]--> 第四范氏：一张表中，尽量不要使用多对多的关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#第五范氏-从最终结构重新建立原始结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="第五范氏：从最终结构重新建立原始结构"><!--[--><!--]--> 第五范氏：从最终结构重新建立原始结构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-事务的四大特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 事务的四大特性"><!--[--><!--]--> 2 事务的四大特性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#acid" class="router-link-active router-link-exact-active sidebar-item" aria-label="ACID"><!--[--><!--]--> ACID <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#时开启的同时互不干扰-相互隔离" class="router-link-active router-link-exact-active sidebar-item" aria-label="时开启的同时互不干扰，相互隔离"><!--[--><!--]--> 时开启的同时互不干扰，相互隔离 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-事务的并发问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 事务的并发问题"><!--[--><!--]--> 3 事务的并发问题 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到"><!--[--><!--]--> 1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致"><!--[--><!--]--> 2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致"><!--[--><!--]--> 3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-事务的隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 事务的隔离级别"><!--[--><!--]--> 4 事务的隔离级别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取"><!--[--><!--]--> 1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-但是会出现脏读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，但是会出现脏读"><!--[--><!--]--> 解决了事务更新丢失，但是会出现脏读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-读提交-第一个事务读取-其他数据可以进行读写操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 读提交：第一个事务读取，其他数据可以进行读写操作"><!--[--><!--]--> 2 读提交：第一个事务读取，其他数据可以进行读写操作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-但是可能出现不可重复读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，但是可能出现不可重复读"><!--[--><!--]--> 解决了事务更新丢失，脏读，但是可能出现不可重复读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写"><!--[--><!--]--> 3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，不可重复读，但是会出现幻读"><!--[--><!--]--> 解决了事务更新丢失，脏读，不可重复读，但是会出现幻读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行）"><!--[--><!--]--> 4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#解决了事务更新丢失-脏读-不可重复的-幻读" class="router-link-active router-link-exact-active sidebar-item" aria-label="解决了事务更新丢失，脏读，不可重复的，幻读"><!--[--><!--]--> 解决了事务更新丢失，脏读，不可重复的，幻读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#事务排队执行-但是性能低-一般不会被使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="事务排队执行，但是性能低，一般不会被使用"><!--[--><!--]--> 事务排队执行，但是性能低，一般不会被使用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#三-sql-索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="三 sql 索引"><!--[--><!--]--> 三 sql 索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-什么是索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 什么是索引"><!--[--><!--]--> 1 什么是索引 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引是数据库的一个排序的数据结构，索引使用B树，B+树实现"><!--[--><!--]--> 索引是数据库的一个排序的数据结构，索引使用B树，B+树实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-索引的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 索引的作用"><!--[--><!--]--> 2 索引的作用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#快速查找-更新表中数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="快速查找，更新表中数据"><!--[--><!--]--> 快速查找，更新表中数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#代价-数据库存储空间增加-插入和修改花费时间较多" class="router-link-active router-link-exact-active sidebar-item" aria-label="代价：数据库存储空间增加，插入和修改花费时间较多"><!--[--><!--]--> 代价：数据库存储空间增加，插入和修改花费时间较多 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-索引的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 索引的分类"><!--[--><!--]--> 3 索引的分类 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-普通索引-仅加速查询" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 普通索引：仅加速查询"><!--[--><!--]--> 1 普通索引：仅加速查询 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-索引的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 索引的优缺点"><!--[--><!--]--> 4 索引的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点-可以大大的提升性能" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：可以大大的提升性能"><!--[--><!--]--> 优点：可以大大的提升性能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-唯一索引-可以保证每一行数据的唯一性" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 唯一索引：可以保证每一行数据的唯一性"><!--[--><!--]--> 1 唯一索引：可以保证每一行数据的唯一性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-提升了数据的检索速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 提升了数据的检索速度"><!--[--><!--]--> 2 提升了数据的检索速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-可以加速表与表之间的连接" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 可以加速表与表之间的连接"><!--[--><!--]--> 3 可以加速表与表之间的连接 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-查询速度快" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 查询速度快"><!--[--><!--]--> 4 查询速度快 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点"><!--[--><!--]--> 缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度"><!--[--><!--]--> 1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大）"><!--[--><!--]--> 2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-维护索引时间增加" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 维护索引时间增加"><!--[--><!--]--> 3 维护索引时间增加 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-b-树和-b-树" class="router-link-active router-link-exact-active sidebar-item" aria-label="5  B 树和 B+ 树"><!--[--><!--]--> 5  B 树和 B+ 树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#四-mysql-的存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="四 mysql 的存储引擎"><!--[--><!--]--> 四 mysql 的存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-mysql-的存储引擎有那些" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  mysql 的存储引擎有那些"><!--[--><!--]--> 1  mysql 的存储引擎有那些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-mysql-的存储过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  mysql 的存储过程"><!--[--><!--]--> 2  mysql 的存储过程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用"><!--[--><!--]--> 存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可以使用一个命令对象调用存储过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可以使用一个命令对象调用存储过程"><!--[--><!--]--> 1 可以使用一个命令对象调用存储过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-存储过程的优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 存储过程的优缺点"><!--[--><!--]--> 3 存储过程的优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点"><!--[--><!--]--> 优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-存储过程是预编译过的-执行效率高" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 存储过程是预编译过的，执行效率高"><!--[--><!--]--> 1 存储过程是预编译过的，执行效率高 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信）"><!--[--><!--]--> 2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-安全性高-需要有一定权限的用户执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 安全性高，需要有一定权限的用户执行"><!--[--><!--]--> 3 安全性高，需要有一定权限的用户执行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-可以重复使用-减少代码量" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 可以重复使用，减少代码量"><!--[--><!--]--> 4 可以重复使用，减少代码量 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-移植性差" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：移植性差"><!--[--><!--]--> 缺点：移植性差 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#五-sql-优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="五 sql 优化"><!--[--><!--]--> 五 sql 优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-怎么查找需要优化的数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 怎么查找需要优化的数据"><!--[--><!--]--> 1 怎么查找需要优化的数据 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#定位——分析——解决" class="router-link-active router-link-exact-active sidebar-item" aria-label="定位——分析——解决"><!--[--><!--]--> 定位——分析——解决 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#一内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="一内存"><!--[--><!--]--> 一内存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-类加载的过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 类加载的过程"><!--[--><!--]--> 1 类加载的过程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#加载——校验——准备——解析——初始化——使用——卸载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载——校验——准备——解析——初始化——使用——卸载"><!--[--><!--]--> 加载——校验——准备——解析——初始化——使用——卸载 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-java-中类的声明周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  java 中类的声明周期"><!--[--><!--]--> 2  java 中类的声明周期 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#加载——连接——初始化——使用——卸载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载——连接——初始化——使用——卸载"><!--[--><!--]--> 加载——连接——初始化——使用——卸载 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-什么是双亲委派模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 什么是双亲委派模型"><!--[--><!--]--> 3 什么是双亲委派模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#双亲委派模型是一个类的加载过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="双亲委派模型是一个类的加载过程"><!--[--><!--]--> 双亲委派模型是一个类的加载过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" class="router-link-active router-link-exact-active sidebar-item" aria-label="一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父"><!--[--><!--]--> 一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载"><!--[--><!--]--> 加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#优点-防止内存中出现多份同样的字节码" class="router-link-active router-link-exact-active sidebar-item" aria-label="优点：防止内存中出现多份同样的字节码"><!--[--><!--]--> 优点：防止内存中出现多份同样的字节码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-堆和栈道区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 堆和栈道区别"><!--[--><!--]--> 4 堆和栈道区别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#栈-内存用来存储局部变量和方法的调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="栈：内存用来存储局部变量和方法的调用"><!--[--><!--]--> 栈：内存用来存储局部变量和方法的调用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-cg-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 CG 算法"><!--[--><!--]--> 二 CG 算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-jvm-有那些垃圾回收算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  JVM 有那些垃圾回收算法"><!--[--><!--]--> 1  JVM 有那些垃圾回收算法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#标记-清除算法——标记-整理算法——复制算法——分代算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="标记-清除算法——标记-整理算法——复制算法——分代算法"><!--[--><!--]--> 标记-清除算法——标记-整理算法——复制算法——分代算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-标记-清除算法-标记无用的对象-然后进行清除回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 标记-清除算法：标记无用的对象，然后进行清除回收"><!--[--><!--]--> 1 标记-清除算法：标记无用的对象，然后进行清除回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-效率不高-无法清除垃圾碎片" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：效率不高，无法清除垃圾碎片"><!--[--><!--]--> 缺点：效率不高，无法清除垃圾碎片 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存"><!--[--><!--]--> 2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后"><!--[--><!--]--> 3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#将或者的对象复制到另一个区域中-再清除用完的区域" class="router-link-active router-link-exact-active sidebar-item" aria-label="将或者的对象复制到另一个区域中，再清除用完的区域"><!--[--><!--]--> 将或者的对象复制到另一个区域中，再清除用完的区域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#缺点-内存使用率低-只有原来的一般空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="缺点：内存使用率低，只有原来的一般空间"><!--[--><!--]--> 缺点：内存使用率低，只有原来的一般空间 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代"><!--[--><!--]--> 4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#新生代一般采用复制算法-老年代一般采用标记整理算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="新生代一般采用复制算法，老年代一般采用标记整理算法"><!--[--><!--]--> 新生代一般采用复制算法，老年代一般采用标记整理算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-jvm-的垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  JVM 的垃圾回收器"><!--[--><!--]--> 2  JVM 的垃圾回收器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#常用-cms、g-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用：CMS、G 1"><!--[--><!--]--> 常用：CMS、G 1 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-cms-垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  CMS 垃圾回收器"><!--[--><!--]--> 3  CMS 垃圾回收器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" class="router-link-active router-link-exact-active sidebar-item" aria-label="CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片"><!--[--><!--]--> CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-新生代和老年代的垃圾回收期有哪些-有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 新生代和老年代的垃圾回收期有哪些，有什么区别"><!--[--><!--]--> 4 新生代和老年代的垃圾回收期有哪些，有什么区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-垃圾回收器是怎么工作的" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 垃圾回收器是怎么工作的"><!--[--><!--]--> 5 垃圾回收器是怎么工作的 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间）"><!--[--><!--]--> 分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-新生代-使用的是复制算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 新生代：使用的是复制算法"><!--[--><!--]--> 1 新生代：使用的是复制算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法"><!--[--><!--]--> 2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-java-中有那些引用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="6  java 中有那些引用类型"><!--[--><!--]--> 6  java 中有那些引用类型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#强引用——软引用——弱引用——虚引用" class="router-link-active router-link-exact-active sidebar-item" aria-label="强引用——软引用——弱引用——虚引用"><!--[--><!--]--> 强引用——软引用——弱引用——虚引用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-强引用-发生gc时不会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 强引用：发生GC时不会被回收"><!--[--><!--]--> 1 强引用：发生GC时不会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收"><!--[--><!--]--> 2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收"><!--[--><!--]--> 3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知"><!--[--><!--]--> 4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-gc-的触发条件" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  GC 的触发条件"><!--[--><!--]--> 7  GC 的触发条件 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#老年区空间不足、方法区空间不足、" class="router-link-active router-link-exact-active sidebar-item" aria-label="老年区空间不足、方法区空间不足、"><!--[--><!--]--> 老年区空间不足、方法区空间不足、 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#当复制算法等-进入老年代时平均大小大于老年代的空间时" class="router-link-active router-link-exact-active sidebar-item" aria-label="当复制算法等，进入老年代时平均大小大于老年代的空间时"><!--[--><!--]--> 当复制算法等，进入老年代时平均大小大于老年代的空间时 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#一线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="一线程"><!--[--><!--]--> 一线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-进程和线程的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 进程和线程的区别"><!--[--><!--]--> 1 进程和线程的区别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#进程-应用程序执行的实例-有独立的内存空间和系统资源" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程：应用程序执行的实例，有独立的内存空间和系统资源"><!--[--><!--]--> 进程：应用程序执行的实例，有独立的内存空间和系统资源 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#线程-cpu调度和分派的基本单位-应用程序是最小的单位" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程：CPU调度和分派的基本单位，应用程序是最小的单位"><!--[--><!--]--> 线程：CPU调度和分派的基本单位，应用程序是最小的单位 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-线程的状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 线程的状态"><!--[--><!--]--> 2 线程的状态 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#创建线程——就绪状态——运行状态——阻塞状态——死亡状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="创建线程——就绪状态——运行状态——阻塞状态——死亡状态"><!--[--><!--]--> 创建线程——就绪状态——运行状态——阻塞状态——死亡状态 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-常用方法-调度" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 常用方法（调度）"><!--[--><!--]--> 3 常用方法（调度） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-线程的有点" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 线程的有点"><!--[--><!--]--> 4 线程的有点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#_1-可重复使用存在的线程-减少对象创建销毁的开销" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 可重复使用存在的线程，减少对象创建销毁的开销"><!--[--><!--]--> 1 可重复使用存在的线程，减少对象创建销毁的开销 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 提高系统资源的使用率，避免多资源竞争，避免阻塞"><!--[--><!--]--> 2 提高系统资源的使用率，避免多资源竞争，避免阻塞 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-提供定时-定期执行-单线程、并发等控制功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 提供定时，定期执行，单线程、并发等控制功能"><!--[--><!--]--> 3 提供定时，定期执行，单线程、并发等控制功能 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-实现多线程的几种方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 实现多线程的几种方法"><!--[--><!--]--> 5 实现多线程的几种方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-创建线程池的几种方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 创建线程池的几种方法"><!--[--><!--]--> 6 创建线程池的几种方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-线程池的状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 线程池的状态"><!--[--><!--]--> 7 线程池的状态 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_8-线程池中-submit-和-execute-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="8 线程池中 submit （）和 execute 的区别"><!--[--><!--]--> 8 线程池中 submit （）和 execute 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_9-线程池的七大核心参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 线程池的七大核心参数"><!--[--><!--]--> 9 线程池的七大核心参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二线程安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="二线程安全"><!--[--><!--]--> 二线程安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-java-中怎么保证线程的安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  Java 中怎么保证线程的安全"><!--[--><!--]--> 1  Java 中怎么保证线程的安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-什么是死锁-怎么防止" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 什么是死锁，怎么防止"><!--[--><!--]--> 2 什么是死锁，怎么防止 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进"><!--[--><!--]--> 死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#就会造成死锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="就会造成死锁"><!--[--><!--]--> 就会造成死锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-synchronized-的底层实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="3  synchronized 的底层实现原理"><!--[--><!--]--> 3  synchronized 的底层实现原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" class="router-link-active router-link-exact-active sidebar-item" aria-label="每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候"><!--[--><!--]--> 每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#尝试获取锁的每个对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="尝试获取锁的每个对象"><!--[--><!--]--> 尝试获取锁的每个对象 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-synchronized-和-lock-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  synchronized 和 lock 的区别"><!--[--><!--]--> 4  synchronized 和 lock 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-锁的类别" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 锁的类别"><!--[--><!--]--> 5 锁的类别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#一容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="一容器"><!--[--><!--]--> 一容器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-java-中有那些容器" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  java 中有那些容器"><!--[--><!--]--> 1  java 中有那些容器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-5-大容器的特点、用法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 5 大容器的特点、用法"><!--[--><!--]--> 2 5 大容器的特点、用法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-那些容器是安全的-那些不安全" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 那些容器是安全的，那些不安全"><!--[--><!--]--> 3 那些容器是安全的，那些不安全 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#二-java-基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="二 java 基础"><!--[--><!--]--> 二 java 基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_1-sring-的常用方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1  Sring 的常用方法"><!--[--><!--]--> 1  Sring 的常用方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_2-final-关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="2  final 关键字"><!--[--><!--]--> 2  final 关键字 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#修饰类-不能被继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰类：不能被继承"><!--[--><!--]--> 修饰类：不能被继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#修饰方法-不能被重写" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰方法：不能被重写"><!--[--><!--]--> 修饰方法：不能被重写 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#修饰变量-不能被修改" class="router-link-active router-link-exact-active sidebar-item" aria-label="修饰变量：不能被修改"><!--[--><!--]--> 修饰变量：不能被修改 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_3-方法重写和重载" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 方法重写和重载"><!--[--><!--]--> 3 方法重写和重载 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#重写-参数名、方法名、返回值必须保持一致" class="router-link-active router-link-exact-active sidebar-item" aria-label="重写：参数名、方法名、返回值必须保持一致"><!--[--><!--]--> 重写：参数名、方法名、返回值必须保持一致 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/docs/interview/interview10.html#_4-stringbuilder-、-stringbuffer-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="4  StringBuilder 、 StringBuffer 区别"><!--[--><!--]--> 4  StringBuilder 、 StringBuffer 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_5-为什么重写-equals-必须重写-hashcode-方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 为什么重写 equals 必须重写 hashCode 方法"><!--[--><!--]--> 5 为什么重写 equals 必须重写 hashCode 方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_6-数组在内存中如何分配" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 数组在内存中如何分配"><!--[--><!--]--> 6 数组在内存中如何分配 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/docs/interview/interview10.html#_7-java-中的四大引用类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="7  java 中的四大引用类型"><!--[--><!--]--> 7  java 中的四大引用类型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/docs/interview/interview10.html#强引用——软引用——弱引用——虚引用-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="强引用——软引用——弱引用——虚引用"><!--[--><!--]--> 强引用——软引用——弱引用——虚引用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="_1-微服务" tabindex="-1"><a class="header-anchor" href="#_1-微服务" aria-hidden="true">#</a> 1 微服务</h1><h2 id="一-springcloud-微服务" tabindex="-1"><a class="header-anchor" href="#一-springcloud-微服务" aria-hidden="true">#</a> 一 SpringCloud 微服务</h2><h2 id="_1-什么是微服务" tabindex="-1"><a class="header-anchor" href="#_1-什么是微服务" aria-hidden="true">#</a> 1 什么是微服务</h2><blockquote><p>微服务是一种架构思想，，，它是有多个组件组合而成---&gt;</p><p>任何一个微服务都是一个独立的进程（独立开发、独立维护、独立部署等）。。</p></blockquote><h2 id="_2-微服务框架的优势" tabindex="-1"><a class="header-anchor" href="#_2-微服务框架的优势" aria-hidden="true">#</a> 2 微服务框架的优势</h2><blockquote><p>1 一个微服务只关注一个特定的业务功能，业务清晰，代码量少。</p><p>开发和维护相对简单。</p><p>（整个应用是由若干个微服务构建而成 所以整个应用也在可控状态）</p><p>2 单个微服务代码量少，启动快</p><p>3 技术栈不受限制，每个小微服务都有他合理的技术栈</p></blockquote><h2 id="_3-springcloud-和微服务的关系" tabindex="-1"><a class="header-anchor" href="#_3-springcloud-和微服务的关系" aria-hidden="true">#</a> 3 SpringCloud 和微服务的关系</h2><blockquote><p>springCloud是一系列框架的集合体 nacos注册中心 Sentinel 熔断/降流 Gateway网关 Sleuth 链路追踪 Seata 分布式事务 Redisson---Redlock分布式锁</p></blockquote><h2 id="_4-springboot-和-springcloud-的区别" tabindex="-1"><a class="header-anchor" href="#_4-springboot-和-springcloud-的区别" aria-hidden="true">#</a> 4 SpringBoot 和 SpringCloud 的区别</h2><p>1 SpringBoot专注于开发单体项目</p><p>2 SpringCloud 专注于微服务的协调、整理、治理的框架，，它将SpringBoot开发的单体 项目联合管理起来</p><p>3 springBoot可以单体开发，，，SpringCloud不能离开SpringBoot开发，，属于依赖关系</p><h2 id="_5-什么是-cap" tabindex="-1"><a class="header-anchor" href="#_5-什么是-cap" aria-hidden="true">#</a> 5 什么是 CAP</h2><p>Consistency（一致性）、Availability（可用性）、Partitiontolerance(分区容忍性) 1 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是一样的值 （所有节点访问的都是同一分，最新的数据副本）</p><p>2 可用性（A）：在集群中一部分节点故障后，集群整体是否还能正常使用 （对数据更新具备，高可用性）</p><p>3 分区容忍性（P）：相当于队通信段时间限制 ，如果时间不能在时限内达到一致性，就 会发生分区的情况，，（必须在C，A之间做出选择）</p><p>CAP只能同时满足两个 取舍： 1 如果保证强一致性 采用 CA 放弃P 系统的扩展性降低（mysql采用CA模式）</p><p>2 如果不保证A采用CP的情况下 P的分区会无限延长，可能会造成数据丢失（故障）（Reids）</p><p>3 AP模式 放弃C的一致性，一旦放生分区，数据就会不一致（抢购活动）</p><h2 id="二-naoca-注册中心" tabindex="-1"><a class="header-anchor" href="#二-naoca-注册中心" aria-hidden="true">#</a> 二 Naoca 注册中心</h2><p>1 为什么使用 Nacos</p><blockquote><p>首先，服务器越来越多，不方便维护和管理，也容易造成代码冲突</p><p>可以将配置信息都交由nacos进行集中管理，，统一分配，</p><p>同时启动类上需要加上 @EnableDiscoveryClient 开启服务的注册与发现功能</p></blockquote><h2 id="三-sentinel-熔断-降流" tabindex="-1"><a class="header-anchor" href="#三-sentinel-熔断-降流" aria-hidden="true">#</a> 三 Sentinel 熔断 / 降流</h2><p>什么是熔断，什么是降流</p><blockquote><p>1 熔断：指的是我调用别人，出现了问题，怎么办，返回什么数据，报错等，</p><p>2 降流：指别人调用我请求量太大的话，需要对其限流</p></blockquote><h2 id="_2-怎么设置降流" tabindex="-1"><a class="header-anchor" href="#_2-怎么设置降流" aria-hidden="true">#</a> 2 怎么设置降流</h2><blockquote><p>1 流量监控其原理是 受监控应用流量的被设置的QPS到达指定的阔值的时候 对其进行流量控制，避免瞬间被大批的流量冲垮， 保障了应用的可用性</p><p>使用@SentinelResource的blockHandler可以指定限流后的异常处理方法</p></blockquote><h2 id="_2-熔断" tabindex="-1"><a class="header-anchor" href="#_2-熔断" aria-hidden="true">#</a> 2 熔断</h2><p>在我们 一个服务调用另一个服务如果出现了异常 或其他特殊情况的话 会进行熔断处理</p><blockquote><p>1 一段熔断，断路器的状态是Open打开的</p><p>2 当熔断时间结束后，断路器的状态时 half-Open（可以允许一个进来）</p><p>3 如果接下啦的请求正常的话 断路器的状态是 close （资源就自恢复），</p><p>4 如果失败，断路器的状态还是Open</p><p>使用@SentinelResource的fallBack可以指定熔断后的异常处理方法</p></blockquote><h2 id="四-gateway-网关" tabindex="-1"><a class="header-anchor" href="#四-gateway-网关" aria-hidden="true">#</a> 四 Gateway 网关</h2><p>为什么使用 Gateway 网关</p><blockquote><p>1 可以对微服务系统起到很好的性能优化</p><p>2 Gateway网关可以起到很好的作用，比如：路由、过滤、限流、监控等。。</p></blockquote><h2 id="五-seata-分布式事务" tabindex="-1"><a class="header-anchor" href="#五-seata-分布式事务" aria-hidden="true">#</a> 五 Seata 分布式事务</h2><h3 id="_1-什么是分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-什么是分布式事务" aria-hidden="true">#</a> 1 什么是分布式事务</h3><p>1 在spring中声明事务 通过spring的AOP实现 @TranSactional 中的rollbackFor、notRoolbackFor来实现事务的提交、回滚等</p><p>单服务的情况下 是一个service去访问两个不同的数据库</p><p>在多服务的进程中 可能有多个service 来回调用 来同时访问不同的数据库</p><p>在分布式事务中，它也是遵循了ACID的规范 原子性：要么全部成功，要么全部失败</p><p>一致性：从事务开始-到事务结束，数据库的完整性没有被破坏</p><p>隔离性：在多个事务并行进行 读写、修改等操作是不会交叉而导致数据不一致，</p><p>持久性：事务结束后，对数据的修改是永久性的，不会因为系统故障而造成数据丢失。</p><h3 id="_2-而在seata中有at、tcc、saga和-xa-事务模式" tabindex="-1"><a class="header-anchor" href="#_2-而在seata中有at、tcc、saga和-xa-事务模式" aria-hidden="true">#</a> 2 而在seata中有AT、TCC、SAGA和 XA 事务模式</h3><p>AT模式两阶段提交协议的演变：</p><p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。 二阶段： 提交异步化，非常快速地完成。 回滚通过一阶段的回滚日志进行反向补偿。</p><p>TCC编程模式：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存， Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。</p><h2 id="六分布式锁" tabindex="-1"><a class="header-anchor" href="#六分布式锁" aria-hidden="true">#</a> 六分布式锁</h2><p>可以使用Redisson中的RedLock锁来实现分布式锁</p><p>《RedLock是基于redis实现的分布式锁，它能够保证以下特性》 互斥锁：在任何时候只能有一个客户端持有锁 避免死锁：当客户拿到锁之后，即便是发生了异常或者服务器宕机的情况下， 利用key的存活时间避免死锁</p><h1 id="_2-中间键" tabindex="-1"><a class="header-anchor" href="#_2-中间键" aria-hidden="true">#</a> 2 中间键</h1><h2 id="一-rabbitmq" tabindex="-1"><a class="header-anchor" href="#一-rabbitmq" aria-hidden="true">#</a> 一 RabbitMQ</h2><p>1 什么是 MQ</p><blockquote><p>mq是通过异步发送消息的方式 使流量削峰，解耦，订单处理等问题</p></blockquote><p>2 MQ 的执行流程</p><blockquote><p>管道---生产者---交换机---路由---队列---消费者</p><p>先建立管道从生产者发送消息 到交换机，再从交换机路由到队列，最终到达消费者</p></blockquote><h2 id="_3-mq-的模式有那些" tabindex="-1"><a class="header-anchor" href="#_3-mq-的模式有那些" aria-hidden="true">#</a> 3 MQ 的模式有那些</h2><blockquote><p>1 点对点模式：点对点模式，从发送消息 到接收消息只有一个消费者</p><p>2 工作队列模式：一个队列有多个消费者，但最终只有一个消费者可以接收到消息</p><p>3 发布订阅模式：多对多，多个队列 到多个消费者</p><p>4 路由模式：可以规定消费者</p><p>注解@RabbitListener queuesToDeclare声明队列</p></blockquote><h2 id="_4-mq-怎么确保消息的可靠性" tabindex="-1"><a class="header-anchor" href="#_4-mq-怎么确保消息的可靠性" aria-hidden="true">#</a> 4 MQ 怎么确保消息的可靠性</h2><h3 id="可以采用持久化机制-手动ack" tabindex="-1"><a class="header-anchor" href="#可以采用持久化机制-手动ack" aria-hidden="true">#</a> 可以采用持久化机制+手动ACK</h3><h3 id="_1-开启持久化" tabindex="-1"><a class="header-anchor" href="#_1-开启持久化" aria-hidden="true">#</a> 1 开启持久化</h3><p>交换器和队列的持久化都是通过在声明时将durable参数置为true实现的 消息的持久化是在发送消息指定deliveryMode为 2 实现的</p><p>2 手动开启Ack模式</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>通过手动创建Bean重写SimpleMessageListenerContainer接口
newSimpleMessageListenerContainer将setAcknowledgeMode重新赋值
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3 开启RabbitMQ的持久化。当生产者把消息成功写入RabbitMQ之后，RabbitMQ 就把消息持久化到磁盘。只有当消息成功持久化磁盘之后， 才会回调生产者的接口返回ack消息，否则都算失败，生产者会重新发送。存入磁盘的消息 不会丢失，就算RabbitMQ挂掉了，重启之后，他会读取磁盘中的消息，不会导致消息的丢 失。</p><h2 id="_5-mq-怎么避免消息重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_5-mq-怎么避免消息重复消费-幂等性" aria-hidden="true">#</a> 5 MQ 怎么避免消息重复消费（幂等性）</h2><p>1 可以使用redis的zset类型将消息的id放到redis中， 当ack失败后，再mq将消息传给其他消费者时，先执行setnx查询 如果key存在的话 什么都不做 如果不存在再 ack</p><p>（如果出现死锁的问题的话，再setnx上设置过期时间） （因为set集合就是自动有去重的）</p><h2 id="_6-怎么实现延迟队列" tabindex="-1"><a class="header-anchor" href="#_6-怎么实现延迟队列" aria-hidden="true">#</a> 6 怎么实现延迟队列</h2><h3 id="ttl-死信队列" tabindex="-1"><a class="header-anchor" href="#ttl-死信队列" aria-hidden="true">#</a> TTL+ 死信队列</h3><h3 id="通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" tabindex="-1"><a class="header-anchor" href="#通过ttl机制设置过期时间-再由交换机发送到延迟消费队列-实现延迟功能" aria-hidden="true">#</a> 通过TTL机制设置过期时间 再由交换机发送到延迟消费队列，实现延迟功能</h3><h2 id="二-redis-nosql" tabindex="-1"><a class="header-anchor" href="#二-redis-nosql" aria-hidden="true">#</a> 二 Redis （ NoSql ）</h2><h2 id="_1-为什么使用-redis-使用-redis-的好处" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用-redis-使用-redis-的好处" aria-hidden="true">#</a> 1 为什么使用 redis ，使用 redis 的好处</h2><h3 id="_1-速度快-因为数据存储再内存中" tabindex="-1"><a class="header-anchor" href="#_1-速度快-因为数据存储再内存中" aria-hidden="true">#</a> 1 速度快，因为数据存储再内存中</h3><p>2 redis支持String，list，set，zset，hash ，sorted类型的存储</p><p>3 redis还支持事务，redis的操作都是原子性的，要么全部成功，要么全部失败</p><p>4 可用于缓存，设置key的存储时间</p><p>5 reids还支持数据的持久化，比如rdb和aof模式</p><p>6 reids还有redisson的TryLock锁 实现分布式锁功能</p><h2 id="_2-rdb-和-aof-的持久化机制" tabindex="-1"><a class="header-anchor" href="#_2-rdb-和-aof-的持久化机制" aria-hidden="true">#</a> 2 Rdb 和 Aof 的持久化机制</h2><h3 id="持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" tabindex="-1"><a class="header-anchor" href="#持久化就是把内存-读写到磁盘中-防止服务器宕机数据丢失" aria-hidden="true">#</a> 持久化就是把内存 读写到磁盘中，，防止服务器宕机数据丢失</h3><p>1 Rdb：指定的时间间隔能将你的数据进行快照存储 （如果本次快照刚存储完，下次快照还没存储的时候，服务器宕机了，中间这些数据会丢失）</p><p>2 Aof：每一次收到存储的命令都会用过write函数追加到文件中</p><p>Aof比rdb要更安全，更大 Aof更新频率高 Rdb 性能好</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（如果两者同时开启，会优先使用Aof）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_3-怎么保证-redis-和数据库的一致性" tabindex="-1"><a class="header-anchor" href="#_3-怎么保证-redis-和数据库的一致性" aria-hidden="true">#</a> 3 怎么保证 redis 和数据库的一致性</h2><h3 id="_1-合理的设置缓存过期时间" tabindex="-1"><a class="header-anchor" href="#_1-合理的设置缓存过期时间" aria-hidden="true">#</a> 1 合理的设置缓存过期时间</h3><p>2 增删改数据库的同时，同步更新redis， 可以采用事务的机制来保证数据的一致性</p><p>如果有大量的写数据 同时操作时可以间隔一段时间在同步到MySQL中</p><p>或者使用 alibaba的binlog框架实现</p><h2 id="_4-redis-缓存穿透-缓存雪崩-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_4-redis-缓存穿透-缓存雪崩-缓存击穿" aria-hidden="true">#</a> 4 redis 缓存穿透，缓存雪崩，缓存击穿</h2><p>1 缓存穿透：一个无效ID查询的时候先查Redis如果没有，就会去数据库查询 反复循环</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>解决方案：查询数据库的数据的时候，不管查询到的数据有没有
都通过Redis缓存起来，并设置一个过期时间
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2 缓存雪崩：同一时间 有大量的数据访问 数据库 解决方案：在做缓存的时候通过 固定时间+随机时间 将数据进行缓存 保证数据不会在同一时间失效</p><p>3 缓存击穿：在缓存时间的时候，有大量的热点数据访问数据库，造成缓存击穿 解决方案： 1 最简单的方式就是将 热点数据设置永不超时</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2 对访问的key加互斥锁，如果请求的key不存在就加锁 去数据查拿数据
新的数据过来如果key相等则等 10 s再去缓存拿数据
如果key不同，则直接去缓存拿数据
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-redis-如何实现高并发、高可用" tabindex="-1"><a class="header-anchor" href="#_5-redis-如何实现高并发、高可用" aria-hidden="true">#</a> 5 redis 如何实现高并发、高可用</h2><h3 id="高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" tabindex="-1"><a class="header-anchor" href="#高并发-通过一主多从的模式实现-主节点负责写-从节点负责读-读写分离-实现高并发" aria-hidden="true">#</a> 高并发：通过一主多从的模式实现，主节点负责写，从节点负责读，读写分离，实现高并发</h3><h3 id="高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" tabindex="-1"><a class="header-anchor" href="#高可用-在主节点宕机的情况下-会自动从-从节点随机选取一个变为主节点" aria-hidden="true">#</a> 高可用：在主节点宕机的情况下，会自动从 从节点随机选取一个变为主节点</h3><p>Redis的哨兵模式：通过Sentinel 会不断的监控主服务和从服务 是否正常进行 当检测到某个redis服务出现故障，sentinel会通过Api的方式通知管理员 当redis的主节点失效是 sentinel会自动的讲 从节点随机抽取一个 提升为主节点，并且将 其他的从节点指向新的 主节点</p><h2 id="_6-redis-的性能优化-和解决方案" tabindex="-1"><a class="header-anchor" href="#_6-redis-的性能优化-和解决方案" aria-hidden="true">#</a> 6 redis 的性能优化，和解决方案</h2><p>( 1 )Master最好不要做任何持久化工作，如 RDB内存快照和 AOF日志文件 ( 2 ) 如果数据比较重要，某个 Slave 开启 AOF备份数据，策略设置为每秒同步一次 ( 3 ) 为了主从复制的速度和连接的稳定性， Master和 Slave最好在同一个局域网内 ( 4 ) 尽量避免在压力很大的主库上增加从库 ( 5 ) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master&lt;-Slave 1 &lt;-Slave 2 &lt;- Slave 3 ...</p><h2 id="_7-redis-的-trdlock-红锁的实现" tabindex="-1"><a class="header-anchor" href="#_7-redis-的-trdlock-红锁的实现" aria-hidden="true">#</a> 7 redis 的 TrdLock 红锁的实现</h2><p>1 在获取锁的时候使用 setnx如果返回 0 就是有人在使用 1 就可以获取锁 设置获取锁的超时时间，如果在时间内没获取到 就放弃加锁</p><p>2 释放锁的时候通过UUID 来判断是不是该锁，如果是在通过delete 释放锁</p><h2 id="_8-redis-的过期策略" tabindex="-1"><a class="header-anchor" href="#_8-redis-的过期策略" aria-hidden="true">#</a> 8 redis 的过期策略</h2><p>Key的时间到了不会立即删除 1 定期删除：redis会定期的去查看过期的key会随机删除 3 个 2 惰性删除：如果去查询一个过期的key时，redis会先查看key是否过期 如果过期会立即删除，并且返回空</p><h2 id="三-mybatis" tabindex="-1"><a class="header-anchor" href="#三-mybatis" aria-hidden="true">#</a> 三 Mybatis</h2><h2 id="_1-mybatis-的优缺点" tabindex="-1"><a class="header-anchor" href="#_1-mybatis-的优缺点" aria-hidden="true">#</a> 1 mybatis 的优缺点</h2><h3 id="优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" tabindex="-1"><a class="header-anchor" href="#优点-灵活-解耦-可充用性高-减少代码量-与各种数据库有很好的兼容性" aria-hidden="true">#</a> 优点：灵活，解耦，可充用性高，减少代码量，与各种数据库有很好的兼容性</h3><p>缺点：sql编写工作量打，数据库移植性差</p><h2 id="_2-mybatis-的-1-2-级缓存" tabindex="-1"><a class="header-anchor" href="#_2-mybatis-的-1-2-级缓存" aria-hidden="true">#</a> 2 mybatis 的 1 ， 2 级缓存</h2><p>1 1 级缓存：默认开启的结构Map 第一次进行sql查询的时候会默认的将查询的结果放入sqlsession缓存中，每次查询的 时候先从缓存中取数据，如果缓存中没有的话再去数据库查询，查出来再放入sqlsession中 （如果sql查询语句不同的话，对应的缓存对象也不同）</p><p>2 2 级缓存：手动开启 全局缓存 结构Map 二级缓存是mapper级别的缓存 一个会话首先会放入一级缓存中，如果该会话关闭，就会把一级缓存的数据放入二级缓存中 新的会话就会参照 二级缓存。</p><p>开启会话缓存---》需要再每个Mapper.xml中手动配置</p><p>三级缓存 ，搭配 redis的缓存</p><h1 id="_3-spring-全家桶" tabindex="-1"><a class="header-anchor" href="#_3-spring-全家桶" aria-hidden="true">#</a> 3 Spring 全家桶</h1><h2 id="一-spring" tabindex="-1"><a class="header-anchor" href="#一-spring" aria-hidden="true">#</a> 一 Spring</h2><h2 id="_1-为什么使用-spring" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用-spring" aria-hidden="true">#</a> 1 为什么使用 spring</h2><p>1 方便解藕，可以讲对象间的依赖关系交给spring管理 2 spring支持Apo切面编程，可以很方便的对程序进行监控和拦截 3 ioc，控制反转 4 方便测试，可以联合junit进行单元测试 5 集成其他框架比较方便</p><h2 id="_2-什么是-aop-ioc" tabindex="-1"><a class="header-anchor" href="#_2-什么是-aop-ioc" aria-hidden="true">#</a> 2 什么是 Aop ， Ioc</h2><p>1 Aop切面编程，在原有的基础上通过Aop添加新的功能，而原有的功能并不知道新添加 的功能 简单来说就是：在某个方法/类，执行前打个标记声明干什么，之后执行什么，插入的新的 方法</p><p>2 Ioc 控制反转，负责创建对象，管理对象，（依赖注入的方式） 将创建的对象和对象之间的维护交有Spring管理</p><p>传统：自己new一个对象或者get一个直接/简介获取一个对象（耦合度高） Spring：spring容器使用工厂模式建造对象，不用自己创建，直接调用即可</p><h2 id="_3-spring-的注入方式" tabindex="-1"><a class="header-anchor" href="#_3-spring-的注入方式" aria-hidden="true">#</a> 3 spring 的注入方式</h2><p>1 构造注入：一般都话通过构造注入的方式，@Autowired/@Rsource进行注入 2 setter方式注入：Bean注入</p><h2 id="_4-springbean-的声命周期" tabindex="-1"><a class="header-anchor" href="#_4-springbean-的声命周期" aria-hidden="true">#</a> 4 springBean 的声命周期</h2><p>首先Bean可以通过注解 @BeanFactory创建Bean @ConfigRe 将Bean交由Spring的ioc进行管理</p><p>Bean是单厉模式--每次请求都会创建新的Bean---每次每次request---每次session会话</p><p>实例化-------------属性赋值------------初始化-----------销毁 （容器关闭时销毁） @PostConstruct （初始化init） @PreDestroy（销毁destroy）</p><p>继承Bean的方法BeanNameAware/beanFactroyAware/ApplicationContextAware/ setBeanName/setBeanFactroy/setApplicationContext</p><h2 id="_5-spring-的自动装配" tabindex="-1"><a class="header-anchor" href="#_5-spring-的自动装配" aria-hidden="true">#</a> 5 spring 的自动装配</h2><h3 id="容器不会自动装配" tabindex="-1"><a class="header-anchor" href="#容器不会自动装配" aria-hidden="true">#</a> 容器不会自动装配</h3><p>Spring可以通过BeanFactory中注入的方式来搞定Bean之间的依赖关系，达到自动装配 （尽量少用，如果非要使用可以用ByName来解决）</p><p>byName可以根据bean的名称注入 匹配并装配xml文件中由相同名称定义的Bean</p><h2 id="_6-spring-框架用到了那些设计模式" tabindex="-1"><a class="header-anchor" href="#_6-spring-框架用到了那些设计模式" aria-hidden="true">#</a> 6 spring 框架用到了那些设计模式</h2><p>代理模式：在Aop中使用最多 单例模式：Bean默认是单例模式 工厂模式：BeanFactory 依赖注入模式：BeanFactory/ApplicationContext 试图：Spring的一系列jsp标签</p><h2 id="_7-spring-的事务性" tabindex="-1"><a class="header-anchor" href="#_7-spring-的事务性" aria-hidden="true">#</a> 7 spring 的事务性</h2><h3 id="可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" tabindex="-1"><a class="header-anchor" href="#可以通过注解的方式-保证与数据库的事务性-也是通过acid-的原理实现" aria-hidden="true">#</a> 可以通过注解的方式，保证与数据库的事务性 也是通过ACID 的原理实现</h3><p>@Transactional通过该注解的 rollbackFor/noRollbackFor来实现异常回滚（public修饰） Propagation 事务传播 （ 7 种） Isolation 事务的隔离级别 （已提交、未提交、可重复读） ReadOnly读写默认true读写手动false只读 Timeout 超时时间 原子性：要么全部成功，要么全部失败 一致性：从事务开始-到事务结束，数据库的完整性没有被破坏 隔离性：在多个事务并行进行 读写、修改等操作是不会交叉而导致数据不一致， 持久性：事务结束后，对数据的修改是永久性的，不会因为系统故障而造成数据丢失。</p><h2 id="二-springmvc" tabindex="-1"><a class="header-anchor" href="#二-springmvc" aria-hidden="true">#</a> 二 SpringMVC</h2><h2 id="_1-什么是-springmvc" tabindex="-1"><a class="header-anchor" href="#_1-什么是-springmvc" aria-hidden="true">#</a> 1 什么是 springMvc</h2><p>M：Model 模型 负责业务通信处理数据 service、dao V：View 试图 渲染数据jsp、html等 C：Controller控制层 对接请求，控制MVC的流程 调度模型、选择试图、接受请求、响 应数据、service等</p><p>工作流程： Controller接受请求，调用model处理请求，处理完返回controller，再响应View渲染</p><h2 id="_2-mvc-有那些组件" tabindex="-1"><a class="header-anchor" href="#_2-mvc-有那些组件" aria-hidden="true">#</a> 2 MVC 有那些组件</h2><p>1 .DispatcherServlet 前端控制器 2 .HandlerMapping请求派发,建立请求和处理器的映射 3 .Controller处理器 4 .ModelAndView封装模型和试图信息 4 .ViewResolver视图处理器,定位页面</p><h2 id="三-springboot" tabindex="-1"><a class="header-anchor" href="#三-springboot" aria-hidden="true">#</a> 三 SpringBoot</h2><h2 id="_1-什么是-springboot-你对-springboot-的理解" tabindex="-1"><a class="header-anchor" href="#_1-什么是-springboot-你对-springboot-的理解" aria-hidden="true">#</a> 1 什么是 springBoot/ 你对 springBoot 的理解</h2><h3 id="_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" tabindex="-1"><a class="header-anchor" href="#_1-可以认为是服务与框架的一个框架-简化来配置-整合来所有框架" aria-hidden="true">#</a> 1 可以认为是服务与框架的一个框架，简化来配置，整合来所有框架</h3><p>开发速度快，测试简单，配置简单，部署简单（自带Tomcat），建华maven的配置</p><h2 id="_2-springboot-的配置" tabindex="-1"><a class="header-anchor" href="#_2-springboot-的配置" aria-hidden="true">#</a> 2 springBoot 的配置</h2><p>Application、bootstrap 1 application主要是用于springBoot项目的配置 2 bootstrap 主要是用于springCloud的配置</p><p>有properties 和yml 两种配置类型（区别是格式不同）</p><h2 id="_3-springbootapplication-的作用" tabindex="-1"><a class="header-anchor" href="#_3-springbootapplication-的作用" aria-hidden="true">#</a> 3 SpringBootApplication 的作用</h2><h3 id="放在启动了上、、、此注解中包含三个注解" tabindex="-1"><a class="header-anchor" href="#放在启动了上、、、此注解中包含三个注解" aria-hidden="true">#</a> 放在启动了上、、、此注解中包含三个注解</h3><p>@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration</p><p>1 @SpringBootConfiguration 中只有一个注解@Configuration 表示这是一个配置类 2 @ComponentScan自动扫描包，（交由ioc容器管理） Controller、service底层都是有@Component注解 将这些都自动装配到容器中 Dao、Mapper层需要手动开启@MapperScan指定 3 @EnableAutoConfiguration 讲所有@Configuration加载到 加载到spring容器中</p><h2 id="四-spring-、-springmvc-、-springboot-区别" tabindex="-1"><a class="header-anchor" href="#四-spring-、-springmvc-、-springboot-区别" aria-hidden="true">#</a> 四 spring 、 springMVC 、 springBoot 区别</h2><p>Spring： MVC：前后端交互 SringBoot：整合所有框架</p><h1 id="_4-mysql" tabindex="-1"><a class="header-anchor" href="#_4-mysql" aria-hidden="true">#</a> 4 Mysql</h1><h2 id="一-sql-基础" tabindex="-1"><a class="header-anchor" href="#一-sql-基础" aria-hidden="true">#</a> 一 sql 基础</h2><h2 id="_1-mysql-四大操作" tabindex="-1"><a class="header-anchor" href="#_1-mysql-四大操作" aria-hidden="true">#</a> 1 mysql 四大操作</h2><h3 id="crud" tabindex="-1"><a class="header-anchor" href="#crud" aria-hidden="true">#</a> CRUD</h3><p>1 select 查询 select*fromtable 2 delete删除 deletetable(注意加上where条件 不然删除的是整个表) 3 update修改updatesettablea=bwhere？ 4 insert新增 insertintotable（） value （）</p><h2 id="_2-mysql-常用类型" tabindex="-1"><a class="header-anchor" href="#_2-mysql-常用类型" aria-hidden="true">#</a> 2 mysql 常用类型</h2><p>int、double、declmal（ 0 ， 0 ）、char、varchar、text、blob、date、time、year、dateTime</p><h2 id="_3-mysql-常用关键字" tabindex="-1"><a class="header-anchor" href="#_3-mysql-常用关键字" aria-hidden="true">#</a> 3 mysql 常用关键字</h2><p>Select、from、join、on、where、distinct、where、having、groupby、orderby、limit And、or、like、isnull、isnotnull、between（范围）、top、AS、into（复制）、explain、in 顺序： from-&gt;on-&gt;join-&gt;where-&gt;groupby-&gt;聚合函数 -&gt;having-&gt;select-&gt;distinct-&gt;orderby-&gt; limit Leftjoin （左关联）、rightjoin（右关联）、innerjoin（内关联）所有匹配的都显示</p><h2 id="_4-mysql-常用函数" tabindex="-1"><a class="header-anchor" href="#_4-mysql-常用函数" aria-hidden="true">#</a> 4 mysql 常用函数</h2><h3 id="聚合函数、日期函数、字符串函数、数值函数、流程控制函数" tabindex="-1"><a class="header-anchor" href="#聚合函数、日期函数、字符串函数、数值函数、流程控制函数" aria-hidden="true">#</a> 聚合函数、日期函数、字符串函数、数值函数、流程控制函数</h3><h3 id="_1-聚合函数" tabindex="-1"><a class="header-anchor" href="#_1-聚合函数" aria-hidden="true">#</a> 1 聚合函数</h3><p>Max（最大值）、min（最小值）、count（统计）、sum（求和）、avg（求平均值）</p><h3 id="_2-时间函数" tabindex="-1"><a class="header-anchor" href="#_2-时间函数" aria-hidden="true">#</a> 2 时间函数</h3><p>curDate（当前日期）、curTime（当前时间）、new/sysDate（当前时间）、month（当前月）、 dayName（星期几）、weer（第几周）、dayOfYear（周第几天）、dayOfMonth（月第几天）、 Year（年分）、time_to_sec（时间转秒）、date_add/addDate（添加间隔）、 date_sub/subDate（减去间隔）、addTime（+时间）、subTime（-时间）、date_format（格 式化）</p><p>3 字符串函数： Length（长度）、concat（合并）、insert（替换）、lower（转大写）、upper（转大写）、 Left（左截取）、right（右截取）、trim（删除左右空格）、replace（替换，反新）、 Substring（截取）、reverse（反转）</p><p>4 数值函数： Abs（绝对值）、sqrt（二次方跟）、mod（求余）、ceil（返回大于目标值，上）、floor（下）、 Round（四舍五入）、sign（返回符号）、pow（两个值的次方结果）、sin（正弦）、asin（反）、 Cos（余弦）、acos（反）、tan（正切）、atan（反）、cot（余切）</p><p>5 流控制函数、 If（判断，流程控制）、ifnull（是否为空）、case（搜索语句）</p><h2 id="二-sql-事务" tabindex="-1"><a class="header-anchor" href="#二-sql-事务" aria-hidden="true">#</a> 二 sql 事务</h2><h2 id="_1-数据库的三大范氏" tabindex="-1"><a class="header-anchor" href="#_1-数据库的三大范氏" aria-hidden="true">#</a> 1 数据库的三大范氏</h2><h3 id="第一范氏-数据库的每一列都是不可分割的原子数据" tabindex="-1"><a class="header-anchor" href="#第一范氏-数据库的每一列都是不可分割的原子数据" aria-hidden="true">#</a> 第一范氏：数据库的每一列都是不可分割的原子数据</h3><h3 id="例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" tabindex="-1"><a class="header-anchor" href="#例-地址-可以将地址拆分成多个不同的城市字段-保证了第一范氏-方便查询使用" aria-hidden="true">#</a> 例：地址，可以将地址拆分成多个不同的城市字段，保证了第一范氏，方便查询使用</h3><h3 id="第二范氏-实体的属性不能完全依赖于主关键字" tabindex="-1"><a class="header-anchor" href="#第二范氏-实体的属性不能完全依赖于主关键字" aria-hidden="true">#</a> 第二范氏：实体的属性不能完全依赖于主关键字</h3><h3 id="第三范氏-任何非主属性不依赖于其他主属性" tabindex="-1"><a class="header-anchor" href="#第三范氏-任何非主属性不依赖于其他主属性" aria-hidden="true">#</a> 第三范氏：任何非主属性不依赖于其他主属性</h3><h3 id="第四范氏-一张表中-尽量不要使用多对多的关系" tabindex="-1"><a class="header-anchor" href="#第四范氏-一张表中-尽量不要使用多对多的关系" aria-hidden="true">#</a> 第四范氏：一张表中，尽量不要使用多对多的关系</h3><h3 id="第五范氏-从最终结构重新建立原始结构" tabindex="-1"><a class="header-anchor" href="#第五范氏-从最终结构重新建立原始结构" aria-hidden="true">#</a> 第五范氏：从最终结构重新建立原始结构</h3><h2 id="_2-事务的四大特性" tabindex="-1"><a class="header-anchor" href="#_2-事务的四大特性" aria-hidden="true">#</a> 2 事务的四大特性</h2><h3 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h3><p>原子性（Atomicity）：事务要么全部成功，要么全部失败。 一致性（Consistency）：事务开始到结束，数据库的完整性没有被破坏。 隔离性（Isolation）：多个用户同时操作数据库时，对每个用户开启一个事务，多个事务同</p><h3 id="时开启的同时互不干扰-相互隔离" tabindex="-1"><a class="header-anchor" href="#时开启的同时互不干扰-相互隔离" aria-hidden="true">#</a> 时开启的同时互不干扰，相互隔离</h3><p>持久性（Durability）：事务一旦被提交，数据的改变就是永久性的，数据库故障也不会导致 数据的丢失。</p><h2 id="_3-事务的并发问题" tabindex="-1"><a class="header-anchor" href="#_3-事务的并发问题" aria-hidden="true">#</a> 3 事务的并发问题</h2><h3 id="_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" tabindex="-1"><a class="header-anchor" href="#_1-脏读-读未提交-事务-1-读取到事务-2-的未提交数据-事务-2-回滚了-事务-1-还能查到" aria-hidden="true">#</a> 1 脏读：读未提交，事务 1 读取到事务 2 的未提交数据，事务 2 回滚了，事务 1 还能查到</h3><h3 id="_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" tabindex="-1"><a class="header-anchor" href="#_2-不可重复读-事务-1-读数据-事务-2-修改数据并提交-事务-1-又读了次数据-不一致" aria-hidden="true">#</a> 2 不可重复读：事务 1 读数据，事务 2 修改数据并提交，事务 1 又读了次数据，不一致</h3><h3 id="_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" tabindex="-1"><a class="header-anchor" href="#_3-幻读-事务-1-统计了总数-事务-2-新增一条数据-1-读到的还是第一次的数据-不一致" aria-hidden="true">#</a> 3 幻读：事务 1 统计了总数，事务 2 新增一条数据， 1 读到的还是第一次的数据，不一致</h3><h2 id="_4-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_4-事务的隔离级别" aria-hidden="true">#</a> 4 事务的隔离级别</h2><h3 id="_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" tabindex="-1"><a class="header-anchor" href="#_1-读未提交-第一个事务正在修改数据-其他事务不可进行修改-但是可以读取" aria-hidden="true">#</a> 1 读未提交：第一个事务正在修改数据，其他事务不可进行修改，但是可以读取</h3><h3 id="解决了事务更新丢失-但是会出现脏读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-但是会出现脏读" aria-hidden="true">#</a> 解决了事务更新丢失，但是会出现脏读</h3><h3 id="_2-读提交-第一个事务读取-其他数据可以进行读写操作" tabindex="-1"><a class="header-anchor" href="#_2-读提交-第一个事务读取-其他数据可以进行读写操作" aria-hidden="true">#</a> 2 读提交：第一个事务读取，其他数据可以进行读写操作</h3><h3 id="解决了事务更新丢失-脏读-但是可能出现不可重复读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-但是可能出现不可重复读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，但是可能出现不可重复读</h3><h3 id="_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" tabindex="-1"><a class="header-anchor" href="#_3-可重复读-第一个事务在读写的同时-不允许其他事务进行读写" aria-hidden="true">#</a> 3 可重复读：第一个事务在读写的同时，不允许其他事务进行读写</h3><h3 id="解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-不可重复读-但是会出现幻读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，不可重复读，但是会出现幻读</h3><h3 id="_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" tabindex="-1"><a class="header-anchor" href="#_4-可系列化-最高的事务隔离级别-事务一个一个进行操作-新插入的数据不被执行" aria-hidden="true">#</a> 4 可系列化：最高的事务隔离级别，事务一个一个进行操作（新插入的数据不被执行）</h3><h3 id="解决了事务更新丢失-脏读-不可重复的-幻读" tabindex="-1"><a class="header-anchor" href="#解决了事务更新丢失-脏读-不可重复的-幻读" aria-hidden="true">#</a> 解决了事务更新丢失，脏读，不可重复的，幻读</h3><h3 id="事务排队执行-但是性能低-一般不会被使用" tabindex="-1"><a class="header-anchor" href="#事务排队执行-但是性能低-一般不会被使用" aria-hidden="true">#</a> 事务排队执行，但是性能低，一般不会被使用</h3><h2 id="三-sql-索引" tabindex="-1"><a class="header-anchor" href="#三-sql-索引" aria-hidden="true">#</a> 三 sql 索引</h2><h2 id="_1-什么是索引" tabindex="-1"><a class="header-anchor" href="#_1-什么是索引" aria-hidden="true">#</a> 1 什么是索引</h2><h3 id="索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" tabindex="-1"><a class="header-anchor" href="#索引是数据库的一个排序的数据结构-索引使用b树-b-树实现" aria-hidden="true">#</a> 索引是数据库的一个排序的数据结构，索引使用B树，B+树实现</h3><h2 id="_2-索引的作用" tabindex="-1"><a class="header-anchor" href="#_2-索引的作用" aria-hidden="true">#</a> 2 索引的作用</h2><h3 id="快速查找-更新表中数据" tabindex="-1"><a class="header-anchor" href="#快速查找-更新表中数据" aria-hidden="true">#</a> 快速查找，更新表中数据</h3><h3 id="代价-数据库存储空间增加-插入和修改花费时间较多" tabindex="-1"><a class="header-anchor" href="#代价-数据库存储空间增加-插入和修改花费时间较多" aria-hidden="true">#</a> 代价：数据库存储空间增加，插入和修改花费时间较多</h3><h2 id="_3-索引的分类" tabindex="-1"><a class="header-anchor" href="#_3-索引的分类" aria-hidden="true">#</a> 3 索引的分类</h2><h3 id="_1-普通索引-仅加速查询" tabindex="-1"><a class="header-anchor" href="#_1-普通索引-仅加速查询" aria-hidden="true">#</a> 1 普通索引：仅加速查询</h3><p>2 唯一索引：加速查询 +列值唯一（可以为null）。 3 主键索引：加速查询 +列值唯一（不可以为null）+ 表中只有一个。 4 组合索引：多列值组成一个索引，专门用于组合搜索。 5 全文索引：对文本内容进行分词，进行搜索。</p><p>索引的最佳左匹配原则： 在检索数据是会从最左边开始匹配 唯一、不为空、经常被查询的字段、作为查询条件的字段，都可以建立索引。</p><h2 id="_4-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_4-索引的优缺点" aria-hidden="true">#</a> 4 索引的优缺点</h2><h3 id="优点-可以大大的提升性能" tabindex="-1"><a class="header-anchor" href="#优点-可以大大的提升性能" aria-hidden="true">#</a> 优点：可以大大的提升性能</h3><h3 id="_1-唯一索引-可以保证每一行数据的唯一性" tabindex="-1"><a class="header-anchor" href="#_1-唯一索引-可以保证每一行数据的唯一性" aria-hidden="true">#</a> 1 唯一索引：可以保证每一行数据的唯一性</h3><h3 id="_2-提升了数据的检索速度" tabindex="-1"><a class="header-anchor" href="#_2-提升了数据的检索速度" aria-hidden="true">#</a> 2 提升了数据的检索速度</h3><h3 id="_3-可以加速表与表之间的连接" tabindex="-1"><a class="header-anchor" href="#_3-可以加速表与表之间的连接" aria-hidden="true">#</a> 3 可以加速表与表之间的连接</h3><h3 id="_4-查询速度快" tabindex="-1"><a class="header-anchor" href="#_4-查询速度快" aria-hidden="true">#</a> 4 查询速度快</h3><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><h3 id="_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" tabindex="-1"><a class="header-anchor" href="#_1-当表进行增、删、改的时候-索引需要维护-降低了数据的维护速度" aria-hidden="true">#</a> 1 当表进行增、删、改的时候，索引需要维护，降低了数据的维护速度</h3><h3 id="_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" tabindex="-1"><a class="header-anchor" href="#_2-每一个索引都需要占理物理空间-聚簇索引-占理的空间更大" aria-hidden="true">#</a> 2 每一个索引都需要占理物理空间，（聚簇索引，占理的空间更大）</h3><h3 id="_3-维护索引时间增加" tabindex="-1"><a class="header-anchor" href="#_3-维护索引时间增加" aria-hidden="true">#</a> 3 维护索引时间增加</h3><h2 id="_5-b-树和-b-树" tabindex="-1"><a class="header-anchor" href="#_5-b-树和-b-树" aria-hidden="true">#</a> 5 B 树和 B+ 树</h2><p>Hash索引和B+树索引的区别： Hash索引查询效率高，不能排序，不能查找。B+树索引，可以范围查找、可以排序。</p><p>1 树的每个节点都存储在key和Data，组成的树，读写代价低， 并且叶子节点的指针为null，叶子节点不包含任何关键字的信息。</p><p>2 B+树的叶子节点包含了全部都关键字信息，并且指向来含有这些关键字的指针， 且叶子节点本身根据关键字从小到大的顺序链接，查询效率稳定。</p><p>因为B+树，叶子节点的关键字存储 的路径长度相同，所以查询效率相同。</p><h2 id="四-mysql-的存储引擎" tabindex="-1"><a class="header-anchor" href="#四-mysql-的存储引擎" aria-hidden="true">#</a> 四 mysql 的存储引擎</h2><h2 id="_1-mysql-的存储引擎有那些" tabindex="-1"><a class="header-anchor" href="#_1-mysql-的存储引擎有那些" aria-hidden="true">#</a> 1 mysql 的存储引擎有那些</h2><p>最常用的有innoDB，myISAM，memory 1 事务安全：innoDB支持事务安全，myISAM和memory不支持。 2 存储限制：innoDB有 64 TB的存储限制，myISAM和memory不固定。 3 空间使用：innoDB对空间使用程度较高，myISAM和memory对空间使用较低。 4 内存使用：innoDB和memory对内存使用较高，myISAM对内存使用较低。 5 插入速度：innoDB插入速度较低，myISAM和memory插入速度较高。 6 外键支持：innoDB对外键支持情况好，myISAM和memory不支持外键。</p><h2 id="_2-mysql-的存储过程" tabindex="-1"><a class="header-anchor" href="#_2-mysql-的存储过程" aria-hidden="true">#</a> 2 mysql 的存储过程</h2><h3 id="存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" tabindex="-1"><a class="header-anchor" href="#存储过程-预编译模式-只创建一次-后续在程序中可以多次调用" aria-hidden="true">#</a> 存储过程（预编译模式）：只创建一次，后续在程序中可以多次调用</h3><h3 id="_1-可以使用一个命令对象调用存储过程" tabindex="-1"><a class="header-anchor" href="#_1-可以使用一个命令对象调用存储过程" aria-hidden="true">#</a> 1 可以使用一个命令对象调用存储过程</h3><p>2 可以使用外部程序调用，列：java程序。</p><h2 id="_3-存储过程的优缺点" tabindex="-1"><a class="header-anchor" href="#_3-存储过程的优缺点" aria-hidden="true">#</a> 3 存储过程的优缺点</h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><h3 id="_1-存储过程是预编译过的-执行效率高" tabindex="-1"><a class="header-anchor" href="#_1-存储过程是预编译过的-执行效率高" aria-hidden="true">#</a> 1 存储过程是预编译过的，执行效率高</h3><h3 id="_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" tabindex="-1"><a class="header-anchor" href="#_2-存储过程是存放在代码库的-通过名字直接调用-减少网络通信" aria-hidden="true">#</a> 2 存储过程是存放在代码库的，通过名字直接调用（减少网络通信）</h3><h3 id="_3-安全性高-需要有一定权限的用户执行" tabindex="-1"><a class="header-anchor" href="#_3-安全性高-需要有一定权限的用户执行" aria-hidden="true">#</a> 3 安全性高，需要有一定权限的用户执行</h3><h3 id="_4-可以重复使用-减少代码量" tabindex="-1"><a class="header-anchor" href="#_4-可以重复使用-减少代码量" aria-hidden="true">#</a> 4 可以重复使用，减少代码量</h3><h3 id="缺点-移植性差" tabindex="-1"><a class="header-anchor" href="#缺点-移植性差" aria-hidden="true">#</a> 缺点：移植性差</h3><h2 id="五-sql-优化" tabindex="-1"><a class="header-anchor" href="#五-sql-优化" aria-hidden="true">#</a> 五 sql 优化</h2><h2 id="_1-怎么查找需要优化的数据" tabindex="-1"><a class="header-anchor" href="#_1-怎么查找需要优化的数据" aria-hidden="true">#</a> 1 怎么查找需要优化的数据</h2><h3 id="定位——分析——解决" tabindex="-1"><a class="header-anchor" href="#定位——分析——解决" aria-hidden="true">#</a> 定位——分析——解决</h3><p>1 定位：首先先查找定位需要优化的sql语句（debug、日志（show.log）） 1 可以通过mysql的慢查询 查询执行慢的语句show.log 2 可以通过Druid数据源，sql监控，获取执行慢的语句 3 采用第三方软件 innotop 4 SpringAop环绕通知</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>5 阿里云，腾讯云的sql检测报告，优化建议
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2 分析：分析sql执行慢的原因。解决：解决问题优化 1 并发量（缓存，数据库扩容（mycat））。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>2 数据量（分页，数据库分片（按月））。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>3 最短路径（关系型数据库，尽量以最短的线路，拿出数据）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>4 索引（避免索引牵扯运算、最佳左匹配原则、索引是否生效（explain）、索引数量）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>5 计算（避免索引参与运算、尽量把运算放入代码中）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>6 冗余（尽量避免有冗余的条件在sql中执行、简化sql）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>7 条件顺序（能放on中过滤的尽量不要放入where中，最后是having）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_5-jvm" tabindex="-1"><a class="header-anchor" href="#_5-jvm" aria-hidden="true">#</a> 5 JVM</h1><h2 id="一内存" tabindex="-1"><a class="header-anchor" href="#一内存" aria-hidden="true">#</a> 一内存</h2><h2 id="_1-类加载的过程" tabindex="-1"><a class="header-anchor" href="#_1-类加载的过程" aria-hidden="true">#</a> 1 类加载的过程</h2><h3 id="加载——校验——准备——解析——初始化——使用——卸载" tabindex="-1"><a class="header-anchor" href="#加载——校验——准备——解析——初始化——使用——卸载" aria-hidden="true">#</a> 加载——校验——准备——解析——初始化——使用——卸载</h3><p>1 加载：讲Class的二进制内容加载到方法区（jar、war）。 2 校验：验证Class的二进制文件是否合格（字节码验证、符号验证）。 3 准备：虚拟机在方法区为class分配内存、初始化静态变量的默认值。 4 解析：验证成员变量、方法、静态变量，是否能正常解析。 5 初始化：在内存中构造一个class对象，来表示该类。</p><h2 id="_2-java-中类的声明周期" tabindex="-1"><a class="header-anchor" href="#_2-java-中类的声明周期" aria-hidden="true">#</a> 2 java 中类的声明周期</h2><h3 id="加载——连接——初始化——使用——卸载" tabindex="-1"><a class="header-anchor" href="#加载——连接——初始化——使用——卸载" aria-hidden="true">#</a> 加载——连接——初始化——使用——卸载</h3><p>1 加载：查找加载类的二进制数据，并在堆中创建一个class对象。 2 连接：验证（文件格式、元数据、字节码等），准备（初始化静态变量的默认值）。 3 初始化：为类的静态变量赋予正确的初始值。 4 使用：new出对象在程序中使用 5 卸载：执行垃圾回收</p><h2 id="_3-什么是双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_3-什么是双亲委派模型" aria-hidden="true">#</a> 3 什么是双亲委派模型</h2><h3 id="双亲委派模型是一个类的加载过程" tabindex="-1"><a class="header-anchor" href="#双亲委派模型是一个类的加载过程" aria-hidden="true">#</a> 双亲委派模型是一个类的加载过程</h3><h3 id="一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" tabindex="-1"><a class="header-anchor" href="#一个类加载器收到类的加载请求-不会先去尝试加载这个类-而是把这个请求委派给父" aria-hidden="true">#</a> 一个类加载器收到类的加载请求，不会先去尝试加载这个类，而是把这个请求委派给父</h3><h3 id="加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" tabindex="-1"><a class="header-anchor" href="#加载器完成-只有当父加载器找不到指定的类事-子加载器才会去加载" aria-hidden="true">#</a> 加载器完成，只有当父加载器找不到指定的类事，子加载器才会去加载</h3><h3 id="优点-防止内存中出现多份同样的字节码" tabindex="-1"><a class="header-anchor" href="#优点-防止内存中出现多份同样的字节码" aria-hidden="true">#</a> 优点：防止内存中出现多份同样的字节码</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>打破：继承ClassLoader类，重写loadClass和findClass方法
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-堆和栈道区别" tabindex="-1"><a class="header-anchor" href="#_4-堆和栈道区别" aria-hidden="true">#</a> 4 堆和栈道区别</h2><h3 id="栈-内存用来存储局部变量和方法的调用" tabindex="-1"><a class="header-anchor" href="#栈-内存用来存储局部变量和方法的调用" aria-hidden="true">#</a> 栈：内存用来存储局部变量和方法的调用</h3><p>堆：内存用来存储java的对象，不论成员变量、局部变量、类变量、都是在堆的内存中。</p><p>栈：线程私有 堆：线程共享</p><p>栈的内存小于堆的内存</p><h2 id="二-cg-算法" tabindex="-1"><a class="header-anchor" href="#二-cg-算法" aria-hidden="true">#</a> 二 CG 算法</h2><h2 id="_1-jvm-有那些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_1-jvm-有那些垃圾回收算法" aria-hidden="true">#</a> 1 JVM 有那些垃圾回收算法</h2><h3 id="标记-清除算法——标记-整理算法——复制算法——分代算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法——标记-整理算法——复制算法——分代算法" aria-hidden="true">#</a> 标记-清除算法——标记-整理算法——复制算法——分代算法</h3><h3 id="_1-标记-清除算法-标记无用的对象-然后进行清除回收" tabindex="-1"><a class="header-anchor" href="#_1-标记-清除算法-标记无用的对象-然后进行清除回收" aria-hidden="true">#</a> 1 标记-清除算法：标记无用的对象，然后进行清除回收</h3><h3 id="缺点-效率不高-无法清除垃圾碎片" tabindex="-1"><a class="header-anchor" href="#缺点-效率不高-无法清除垃圾碎片" aria-hidden="true">#</a> 缺点：效率不高，无法清除垃圾碎片</h3><h3 id="_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" tabindex="-1"><a class="header-anchor" href="#_2-标记-整理算法-标记无用的对象-存活的对象向一端移动-清除边界外的内存" aria-hidden="true">#</a> 2 标记-整理算法：标记无用的对象，存活的对象向一端移动，清除边界外的内存</h3><h3 id="_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" tabindex="-1"><a class="header-anchor" href="#_3-复制算法-按照容量复制两个大小相等的内存区域-有一个用完之后" aria-hidden="true">#</a> 3 复制算法：按照容量复制两个大小相等的内存区域，有一个用完之后</h3><h3 id="将或者的对象复制到另一个区域中-再清除用完的区域" tabindex="-1"><a class="header-anchor" href="#将或者的对象复制到另一个区域中-再清除用完的区域" aria-hidden="true">#</a> 将或者的对象复制到另一个区域中，再清除用完的区域</h3><h3 id="缺点-内存使用率低-只有原来的一般空间" tabindex="-1"><a class="header-anchor" href="#缺点-内存使用率低-只有原来的一般空间" aria-hidden="true">#</a> 缺点：内存使用率低，只有原来的一般空间</h3><h3 id="_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" tabindex="-1"><a class="header-anchor" href="#_4-分代算法-存货对象周期的不同将内存划分几个区域-一般为新生代、老年代" aria-hidden="true">#</a> 4 分代算法：存货对象周期的不同将内存划分几个区域，一般为新生代、老年代</h3><h3 id="新生代一般采用复制算法-老年代一般采用标记整理算法" tabindex="-1"><a class="header-anchor" href="#新生代一般采用复制算法-老年代一般采用标记整理算法" aria-hidden="true">#</a> 新生代一般采用复制算法，老年代一般采用标记整理算法</h3><h2 id="_2-jvm-的垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-jvm-的垃圾回收器" aria-hidden="true">#</a> 2 JVM 的垃圾回收器</h2><h3 id="常用-cms、g-1" tabindex="-1"><a class="header-anchor" href="#常用-cms、g-1" aria-hidden="true">#</a> 常用：CMS、G 1</h3><p>另：serial、serialold、parNew、parallel、parallelold。</p><p>1 CMS：获得最短的时间为目标的收集器。非常适合B/S系统 2 G 1 ：兼容吞吐量和停顿时间的GC实现，JDK 9 以后默认是G 1</p><p>3 serial：最早的单线程回收器。 4 serialold：垃圾回收机的老版本，可以是CMS的备选方案。 5 parNew：是serial的多线程版本。 6 parallel：是parNew的收集器，类似于多线程，可以牺牲等待时间换取吞吐量。 7 parallelold：parallel是使用复制回收算法，parallelold是使用标记整理回收算法。</p><h2 id="_3-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_3-cms-垃圾回收器" aria-hidden="true">#</a> 3 CMS 垃圾回收器</h2><h3 id="cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" tabindex="-1"><a class="header-anchor" href="#cms使用标记-清除算法实现的-牺牲等待时间换取吞吐量-在垃圾回收时会产生大量碎片" aria-hidden="true">#</a> CMS使用标记-清除算法实现的，牺牲等待时间换取吞吐量，在垃圾回收时会产生大量碎片</h3><p>当剩余内存不能满足程序的运行需求时，CMS将临时采用serial的垃圾回收算法机制 此时性能会降低。</p><h2 id="_4-新生代和老年代的垃圾回收期有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_4-新生代和老年代的垃圾回收期有哪些-有什么区别" aria-hidden="true">#</a> 4 新生代和老年代的垃圾回收期有哪些，有什么区别</h2><p>新生代：serial、parNew、parallel、scavenge 老年代：serialold、parallelold、CMS 整堆回收算法：G 1</p><h2 id="_5-垃圾回收器是怎么工作的" tabindex="-1"><a class="header-anchor" href="#_5-垃圾回收器是怎么工作的" aria-hidden="true">#</a> 5 垃圾回收器是怎么工作的</h2><h3 id="分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" tabindex="-1"><a class="header-anchor" href="#分代回收器有两个分区-新生代-默认占-3-1-空间-、老年代-默认占-3-2-空间" aria-hidden="true">#</a> 分代回收器有两个分区：新生代（默认占 3 / 1 空间）、老年代（默认占 3 / 2 空间）</h3><h3 id="_1-新生代-使用的是复制算法" tabindex="-1"><a class="header-anchor" href="#_1-新生代-使用的是复制算法" aria-hidden="true">#</a> 1 新生代：使用的是复制算法</h3><h3 id="_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_2-老年代-在空间达到某个值时-会触发全局回收-一般采用标记-整理算法" aria-hidden="true">#</a> 2 老年代：在空间达到某个值时，会触发全局回收，一般采用标记-整理算法</h3><h2 id="_6-java-中有那些引用类型" tabindex="-1"><a class="header-anchor" href="#_6-java-中有那些引用类型" aria-hidden="true">#</a> 6 java 中有那些引用类型</h2><h3 id="强引用——软引用——弱引用——虚引用" tabindex="-1"><a class="header-anchor" href="#强引用——软引用——弱引用——虚引用" aria-hidden="true">#</a> 强引用——软引用——弱引用——虚引用</h3><h3 id="_1-强引用-发生gc时不会被回收" tabindex="-1"><a class="header-anchor" href="#_1-强引用-发生gc时不会被回收" aria-hidden="true">#</a> 1 强引用：发生GC时不会被回收</h3><h3 id="_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" tabindex="-1"><a class="header-anchor" href="#_2-软引用-有用-但不是必须的对象-发生内存溢出就会被回收" aria-hidden="true">#</a> 2 软引用：有用，但不是必须的对象，发生内存溢出就会被回收</h3><h3 id="_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" tabindex="-1"><a class="header-anchor" href="#_3-弱引用-有用-但不是必须的对象-在下一次gc回收时会被回收" aria-hidden="true">#</a> 3 弱引用：有用，但不是必须的对象，在下一次GC回收时会被回收</h3><h3 id="_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" tabindex="-1"><a class="header-anchor" href="#_4-虚引用-无法通过虚引用获取对象-用途-在gc时返回通知" aria-hidden="true">#</a> 4 虚引用：无法通过虚引用获取对象，用途，在GC时返回通知</h3><h2 id="_7-gc-的触发条件" tabindex="-1"><a class="header-anchor" href="#_7-gc-的触发条件" aria-hidden="true">#</a> 7 GC 的触发条件</h2><h3 id="老年区空间不足、方法区空间不足、" tabindex="-1"><a class="header-anchor" href="#老年区空间不足、方法区空间不足、" aria-hidden="true">#</a> 老年区空间不足、方法区空间不足、</h3><h3 id="当复制算法等-进入老年代时平均大小大于老年代的空间时" tabindex="-1"><a class="header-anchor" href="#当复制算法等-进入老年代时平均大小大于老年代的空间时" aria-hidden="true">#</a> 当复制算法等，进入老年代时平均大小大于老年代的空间时</h3><h1 id="_6-多线程" tabindex="-1"><a class="header-anchor" href="#_6-多线程" aria-hidden="true">#</a> 6 多线程</h1><h2 id="一线程" tabindex="-1"><a class="header-anchor" href="#一线程" aria-hidden="true">#</a> 一线程</h2><h2 id="_1-进程和线程的区别" tabindex="-1"><a class="header-anchor" href="#_1-进程和线程的区别" aria-hidden="true">#</a> 1 进程和线程的区别</h2><h3 id="进程-应用程序执行的实例-有独立的内存空间和系统资源" tabindex="-1"><a class="header-anchor" href="#进程-应用程序执行的实例-有独立的内存空间和系统资源" aria-hidden="true">#</a> 进程：应用程序执行的实例，有独立的内存空间和系统资源</h3><h3 id="线程-cpu调度和分派的基本单位-应用程序是最小的单位" tabindex="-1"><a class="header-anchor" href="#线程-cpu调度和分派的基本单位-应用程序是最小的单位" aria-hidden="true">#</a> 线程：CPU调度和分派的基本单位，应用程序是最小的单位</h3><p>Main方法被称为主线程，一个程序至少有一个主线程</p><p>多线程：一个进程中运行了多个线程，称为多线程 好处：充分的利用cpu资源带来良好的体验</p><h2 id="_2-线程的状态" tabindex="-1"><a class="header-anchor" href="#_2-线程的状态" aria-hidden="true">#</a> 2 线程的状态</h2><h3 id="创建线程——就绪状态——运行状态——阻塞状态——死亡状态" tabindex="-1"><a class="header-anchor" href="#创建线程——就绪状态——运行状态——阻塞状态——死亡状态" aria-hidden="true">#</a> 创建线程——就绪状态——运行状态——阻塞状态——死亡状态</h3><p>1 创建线程：new线程对象。 2 就绪状态：调用start（）方法。 3 运行状态：抢占CPU资源，调用yield（）方法，进入就绪状态。 4 阻塞状态：join()/sleep(),如果阻塞结束，进入就绪状态。 5 死亡状态：线程执行完毕。</p><h2 id="_3-常用方法-调度" tabindex="-1"><a class="header-anchor" href="#_3-常用方法-调度" aria-hidden="true">#</a> 3 常用方法（调度）</h2><p>1 sleep（）：线程休眠。 2 join（）：线程插队。 3 yield（）：线程礼让。 4 run（）：线程启动。 5 start（）：启动所有线程（进入就绪状态，并不能立即执行）。</p><p>6 wait（）：线程等待。 7 notify（）：随机唤醒一个线程（JVM决定）。 8 notifyall（）：唤醒所有等待的线程，（并没有加锁，而是让它们抢占）。 9 volatile（）：修饰变量。</p><p>Run（）方法只是定义来一个线程的执行单元，并没有开启线程资源， 只有调用来start（）方法才可以启动线程，直接调用run（）不会创建线程。</p><p>Wait（）和notify（）必须配合synchronized{}关键字使用。 Wait（）释放锁，notify（）不释放锁。</p><p>可以使用volatile（）的布尔变量来退出正在运行的循环线程，或取消任务来中断线程。</p><h2 id="_4-线程的有点" tabindex="-1"><a class="header-anchor" href="#_4-线程的有点" aria-hidden="true">#</a> 4 线程的有点</h2><h3 id="_1-可重复使用存在的线程-减少对象创建销毁的开销" tabindex="-1"><a class="header-anchor" href="#_1-可重复使用存在的线程-减少对象创建销毁的开销" aria-hidden="true">#</a> 1 可重复使用存在的线程，减少对象创建销毁的开销</h3><h3 id="_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" tabindex="-1"><a class="header-anchor" href="#_2-提高系统资源的使用率-避免多资源竞争-避免阻塞" aria-hidden="true">#</a> 2 提高系统资源的使用率，避免多资源竞争，避免阻塞</h3><h3 id="_3-提供定时-定期执行-单线程、并发等控制功能" tabindex="-1"><a class="header-anchor" href="#_3-提供定时-定期执行-单线程、并发等控制功能" aria-hidden="true">#</a> 3 提供定时，定期执行，单线程、并发等控制功能</h3><h2 id="_5-实现多线程的几种方法" tabindex="-1"><a class="header-anchor" href="#_5-实现多线程的几种方法" aria-hidden="true">#</a> 5 实现多线程的几种方法</h2><p>1 继承Thread类，重写run（）方法，用子类实例调用start（）方法。 2 实现Runnable接口，重写run（）方法。 3 创建Callable接口，重写call（）方法。</p><p>Runnable多个线程可以共享实例变量，callable不行。 Runnable方法没有返回值，callable有返回值。 Runnable的run（）方法只能在内部消化，callable的call（）方法可以抛出异常。</p><h2 id="_6-创建线程池的几种方法" tabindex="-1"><a class="header-anchor" href="#_6-创建线程池的几种方法" aria-hidden="true">#</a> 6 创建线程池的几种方法</h2><p>1 newSingleThreadExecutor（创建单线程线程池，可以保证任务顺序）</p><p>2 newFixedThreadPool（创建定长线程池，可控制线程最大并发数，超出等待）</p><p>3 newCachedThreadPool（创建可缓存线程池，有空闲的线程会回收，任务多，消耗资源）</p><p>4 newScheduledThradPool（创建一个大小无限的线程池，支持定时，周期任务需求）</p><h2 id="_7-线程池的状态" tabindex="-1"><a class="header-anchor" href="#_7-线程池的状态" aria-hidden="true">#</a> 7 线程池的状态</h2><p>1 running：一旦被创建，就处于此状态，可以接受新任务，和已经添加的任务处理。</p><p>2 shutdoww：不接受新任务，但是可以处理已添加的任务。</p><p>3 stop：停止（中断），不接受新任务，不处理已添加的任务，中断正在处理的任务</p><p>4 tidying：所有任务已终止的状态。</p><p>5 terminated：线程池彻底终止的状态。</p><h2 id="_8-线程池中-submit-和-execute-的区别" tabindex="-1"><a class="header-anchor" href="#_8-线程池中-submit-和-execute-的区别" aria-hidden="true">#</a> 8 线程池中 submit （）和 execute 的区别</h2><p>1 submit可以接受runnable类型的参数，execute可以接受runnable和callable类型的参数。 2 submit有返回值（Future），execute没有返回值。 3 submit可以很方便的处理Exception异常。</p><h2 id="_9-线程池的七大核心参数" tabindex="-1"><a class="header-anchor" href="#_9-线程池的七大核心参数" aria-hidden="true">#</a> 9 线程池的七大核心参数</h2><p>1 corePoolSize 核心线程数 2 maximumPoolSize 最大线程数，一般大于等于核心线程数 3 keepAliveTime线程存活时间(针对最大线程数大于核心线程数时，非核心线程) 4 unit 存活时间单位，和线程存活时间配套使用 5 workQueue 任务队列 6 threadFactory创建线程的工程 7 handler拒绝策略</p><h2 id="二线程安全" tabindex="-1"><a class="header-anchor" href="#二线程安全" aria-hidden="true">#</a> 二线程安全</h2><h2 id="_1-java-中怎么保证线程的安全" tabindex="-1"><a class="header-anchor" href="#_1-java-中怎么保证线程的安全" aria-hidden="true">#</a> 1 Java 中怎么保证线程的安全</h2><p>1 最简单的方式是使用synchronized关键字。 2 使用lock锁。 3 使用redisson中的RedLock（红锁）。</p><h2 id="_2-什么是死锁-怎么防止" tabindex="-1"><a class="header-anchor" href="#_2-什么是死锁-怎么防止" aria-hidden="true">#</a> 2 什么是死锁，怎么防止</h2><h3 id="死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" tabindex="-1"><a class="header-anchor" href="#死锁-指在线程中有两个以上的线程在争夺资源的时候-相互等待-如果没有外力推进" aria-hidden="true">#</a> 死锁：指在线程中有两个以上的线程在争夺资源的时候，相互等待，如果没有外力推进</h3><h3 id="就会造成死锁" tabindex="-1"><a class="header-anchor" href="#就会造成死锁" aria-hidden="true">#</a> 就会造成死锁</h3><p>避免：确定顺序获取锁。（newSingleThreadExecutor单线程池） 超时放弃（lock锁就是使用了这种方式）</p><h2 id="_3-synchronized-的底层实现原理" tabindex="-1"><a class="header-anchor" href="#_3-synchronized-的底层实现原理" aria-hidden="true">#</a> 3 synchronized 的底层实现原理</h2><h3 id="每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" tabindex="-1"><a class="header-anchor" href="#每个对象都有一个锁-监视器-当锁占用时就会处于锁定状态-线程执行的时候" aria-hidden="true">#</a> 每个对象都有一个锁（监视器），当锁占用时就会处于锁定状态，线程执行的时候</h3><h3 id="尝试获取锁的每个对象" tabindex="-1"><a class="header-anchor" href="#尝试获取锁的每个对象" aria-hidden="true">#</a> 尝试获取锁的每个对象</h3><p>1 如果每个监视器（monitor）的进入数为 0 时，则线程进入监视器（monitor）， 如果进入数为 1 时，则该线程为监视器（monitor）的拥有者。</p><p>2 如果线程已经占有监视器（monitor），只是重新进入，则进入数+ 1 。</p><p>3 如果其他线程已经占用监视器（monitor），则该线程会进入阻塞状态， 直接到监视器（monitor）的进入数为 0 时，再去尝试获取监视器的所有权限。</p><p>Synchronized是锁定当前变量，同一时刻只有一个线程能访问该变量。</p><h2 id="_4-synchronized-和-lock-的区别" tabindex="-1"><a class="header-anchor" href="#_4-synchronized-和-lock-的区别" aria-hidden="true">#</a> 4 synchronized 和 lock 的区别</h2><p>Synchronized是一个关键字，而Lock是一个借口 Synchronized无法判断锁的状态，而Lock锁可以判断锁的状态 Synchronized是自动释放锁，而Lock是需要手动释放锁。</p><p>Synchronized可重复，不可中断，非公平锁，而Lock可判断，可公平。 Synchronized获取锁的线程阻塞，其他线程都会自动等待，而Lock不会</p><h2 id="_5-锁的类别" tabindex="-1"><a class="header-anchor" href="#_5-锁的类别" aria-hidden="true">#</a> 5 锁的类别</h2><p>Synchronized：关键字（单机锁，一个一个获取，可能会造成死锁） Lock：接口（实现了synchronized的所有功能，但是需要手动释放锁） 方法：（voidlock获取锁，tryLock仅在未使用的情况下获取锁，isLock判断是否被占用） TryLock还可以设置获取锁的等待获取时间 公平锁、非公平锁： 公平锁：是指所有的线程按照排队顺序获取锁。</p><p>非公平锁：指多个线程获取锁的顺序，不是按照申请锁的顺序进行的。</p><p>ReentrantLock创建可以指定析构函数的Boolean类型，得到公平锁/非公平锁（默认非公平）</p><p>可重入锁、不可重入锁： 可重入：指的是可重复的使用锁，在外层用完后，内层还可以用，且不会造成死锁</p><p>不可重入：不可递归调用，递归调用就会产生死锁</p><p>乐观锁、悲观锁： 乐观锁：每次去拿数据的时候都认为别人不会修改，不会上锁， 但是在提交的时候还是会判断，在此期间有没有人去更新数据。</p><p>悲观锁：每次去那数据的时候都认为别人会修改数据，所以每次都会上锁， 有人拿读写数据就会阻止，直到这个锁释放，才会被其他人拿到。</p><h1 id="_7-数据类型" tabindex="-1"><a class="header-anchor" href="#_7-数据类型" aria-hidden="true">#</a> 7 数据类型</h1><h2 id="一容器" tabindex="-1"><a class="header-anchor" href="#一容器" aria-hidden="true">#</a> 一容器</h2><h2 id="_1-java-中有那些容器" tabindex="-1"><a class="header-anchor" href="#_1-java-中有那些容器" aria-hidden="true">#</a> 1 java 中有那些容器</h2><p>String（Array），以及Java.util下的集合类</p><p>1 List： ArrayList：有序，底层是一个空数组，第一次添加数据（ 10 ），扩容 1. 5 倍，查询、修改快。</p><p>LinkedList：双向链表实现，增加、删除快，不需要扩容，（先查询相邻的数据）。</p><p>Vector：初始化[ 10 ]的数据，扩容两倍。</p><p>线程安全：ArrayList（不安全）、LinkedLsit（不安全）、Vector（安全）。</p><p>2 map： HashMap：初始化 16 ，扩容 75 %/ 64 扩容两倍， 1. 7 数组+单项链表， 1. 8 数组+单项+红黑树。 不支持线程同步，无序。</p><p>TreeMap：实现SortMap接口，根据键排序，默认升序</p><p>LinkedHashMap：可以保证HashMap有序，</p><p>HashTable：线程安全（synchronized实现），不允许为bull，比hashMap多了elements方法。</p><p>3 set： Hashset：哈希表实现</p><p>TreeSet：树形结构实现，有序</p><p>4 Queue： 先进先出的原则，linkedList实现了Queue接口，不允许为NUll。 5 Stack： 后进先出的原则</p><h2 id="_2-5-大容器的特点、用法" tabindex="-1"><a class="header-anchor" href="#_2-5-大容器的特点、用法" aria-hidden="true">#</a> 2 5 大容器的特点、用法</h2><p>1 Lsit：有序可重复的集合，可以随意增加删除，使用迭代器遍历。</p><p>2 Map：键值对存储，key不允许重复为null，值可以重复为null。 HashMap不保证顺序，TreeMap可以保证顺序。 可以将key、value单独抽出，KeySet（）方法讲所有keys抽成set。 而Values（）方法可以将所有的values抽成一个集合。</p><p>3 Set：不可重复，没有同步方法，只允许一个为null，只能使用迭代器遍历。</p><p>4 Queue：先进先出原则，linkedList实现了Queue接口，不允许为NUll。</p><p>5 Stack：后进先出原则，测试堆栈是否为空empty（）方法。</p><p>用法： 1 涉及到堆栈，队列等操作：使用list。 2 涉及快速插入删除：LinkedList。 3 涉及快速访问修改：ArrayList。</p><h2 id="_3-那些容器是安全的-那些不安全" tabindex="-1"><a class="header-anchor" href="#_3-那些容器是安全的-那些不安全" aria-hidden="true">#</a> 3 那些容器是安全的，那些不安全</h2><p>安全：Vector、HashTable、Properties。 不安全：ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap。</p><h2 id="二-java-基础" tabindex="-1"><a class="header-anchor" href="#二-java-基础" aria-hidden="true">#</a> 二 java 基础</h2><h2 id="_1-sring-的常用方法" tabindex="-1"><a class="header-anchor" href="#_1-sring-的常用方法" aria-hidden="true">#</a> 1 Sring 的常用方法</h2><p>Equals（比较），format（格式化）、hashCode（哈西码）、isEmpty（）、join（指定拼接）、 Length（长度）、split（分割）、subString（截取）、trim（删除前后空格）、 valueOf（返回指定形式，int。。。）</p><h2 id="_2-final-关键字" tabindex="-1"><a class="header-anchor" href="#_2-final-关键字" aria-hidden="true">#</a> 2 final 关键字</h2><h3 id="修饰类-不能被继承" tabindex="-1"><a class="header-anchor" href="#修饰类-不能被继承" aria-hidden="true">#</a> 修饰类：不能被继承</h3><h3 id="修饰方法-不能被重写" tabindex="-1"><a class="header-anchor" href="#修饰方法-不能被重写" aria-hidden="true">#</a> 修饰方法：不能被重写</h3><h3 id="修饰变量-不能被修改" tabindex="-1"><a class="header-anchor" href="#修饰变量-不能被修改" aria-hidden="true">#</a> 修饰变量：不能被修改</h3><p>Final修饰的常量会放入常量池中。</p><h2 id="_3-方法重写和重载" tabindex="-1"><a class="header-anchor" href="#_3-方法重写和重载" aria-hidden="true">#</a> 3 方法重写和重载</h2><h3 id="重写-参数名、方法名、返回值必须保持一致" tabindex="-1"><a class="header-anchor" href="#重写-参数名、方法名、返回值必须保持一致" aria-hidden="true">#</a> 重写：参数名、方法名、返回值必须保持一致</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Final修饰的不能被重写，static修饰的不能被重写，构造方法不能被重写。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重载：方法名一致，顺序、个数、类型，只要有一个不同即可。 重载与返回值无关，可以抛出不同的异常，可以用不同的修饰符。</p><h2 id="_4-stringbuilder-、-stringbuffer-区别" tabindex="-1"><a class="header-anchor" href="#_4-stringbuilder-、-stringbuffer-区别" aria-hidden="true">#</a> 4 StringBuilder 、 StringBuffer 区别</h2><p>StringBuilder：线程安全 StringBuffer：线程不安全</p><p>大数据的批量拼接使用它两个 的append（）方法。</p><h2 id="_5-为什么重写-equals-必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_5-为什么重写-equals-必须重写-hashcode-方法" aria-hidden="true">#</a> 5 为什么重写 equals 必须重写 hashCode 方法</h2><p>两个值 equals相等hashCode相等，hashCoud相等equals不一定相等。</p><h2 id="_6-数组在内存中如何分配" tabindex="-1"><a class="header-anchor" href="#_6-数组在内存中如何分配" aria-hidden="true">#</a> 6 数组在内存中如何分配</h2><p>在new一个数组时，会在堆中分配空间，然后才返回引用，每个数组成员指向（引用）栈。</p><h2 id="_7-java-中的四大引用类型" tabindex="-1"><a class="header-anchor" href="#_7-java-中的四大引用类型" aria-hidden="true">#</a> 7 java 中的四大引用类型</h2><h3 id="强引用——软引用——弱引用——虚引用-1" tabindex="-1"><a class="header-anchor" href="#强引用——软引用——弱引用——虚引用-1" aria-hidden="true">#</a> 强引用——软引用——弱引用——虚引用</h3><p>强引用：不会被垃圾回收，String类型的，常量。</p><p>软引用：还有用但非必须对象，内存不足时会被回收。</p><p>弱引用：一旦被JVM发现，直接被回收。</p><p>虚引用：主要跟踪垃圾回收的活动。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: knightbreeze@163.com">knightbreeze1</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/docs/interview/Java.html" class="" aria-label="Java基础面试题"><!--[--><!--]--> Java基础面试题 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-187343ba.js" defer></script>
  </body>
</html>
